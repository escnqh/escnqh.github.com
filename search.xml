<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[2017年的十一月]]></title>
      <url>/2017/11/29/2017%E5%B9%B411%E6%9C%88/</url>
      <content type="html"><![CDATA[<p>先说说项目的推进吧，整个十一月发生了很多事情， AR留影项目做的并不顺利，在（完全）没有什么进展的情况下，我凭借自己用OpenCV做的一个标记特征点的Demo过了校级大创的中期答辩（虽然不管其他项目做的有多烂都过了，我告诉自己我这个跟他们的可不一样）。我自己跑通了移植到Android的OrbSlam（包含可用的接口，处理好了JIN层）<a href="https://github.com/escnqh/OrbSlam2Test" target="_blank" rel="external">项目地址</a>需要注意的是在使用时需要手动在Android.mk文件中配置你的OpenCV路径（基于AndroidStudio3.0和gcc编译，你可能需要配置），然后就是编译成功生成的是armeabi-v7a的动态库，需要你自己拷贝到Libs目录下。  </p>
<p>做完这一部分得到了<a href="https://github.com/qinzhonghe" target="_blank" rel="external">覃忠和</a>同学的帮助，他对cpp的掌握OpenCV的使用经验以及cmake编译的知识让项目的进度更快，在后面对OrbSlam的使用这一方面，我们还会一同继续努力。  </p>
<p>为了赶项目开发的进度，在<a href="https://github.com/youyinnn" target="_blank" rel="external">大君</a>的提醒下我们开始了项目业务方面的开发，我们简单梳理了一下业务逻辑分配了小组分工。现在依旧比较头疼的部分还是三维重建和AR部分（分身乏力呀）。目前的（长期依赖）状态是我一个人按照自己的思路一路刚，我深深感觉到自己学的不够经验也不足，小组成员帮不上忙我也怪不了他们，因为真的是从0开始，我知道很困难。所以我开始找朋友，找相关的做过SLAM的，做过计算机视觉，了解OpenCV或者对我的项目感兴趣的人帮忙，我也确实在他们身上学到了很多东西。  </p>
<p>这个月还考了三门试，<code>信息安全</code>，重修的<code>大物</code>和<code>软件测试与质量管理</code>。月中的时候，也就是考大物的前一天晚上跟朋友们出去吃饭，结果第二天一直吐进了校医院。还有就是这个月组织了两期<code>科研沙龙</code>第一期说的是Android和iOS开发，第二期找了一些学长学姐来讲考研、保研、硕士经历。将近月底的时候被院里的组织员找去谈话，算是预备党员了。  </p>
<p>现在是月底了在我写这篇博客的时候我的眼睛是肿的==大概得了沙眼。  </p>
<p>我从中国图书网买了四本书，今天才到。<br>|书名|作者|出版社|<br>|-|-|-|<br>|Android源码设计模式 解析与实战 第2版|何红辉/关爱民|人民邮电出版社|<br>|Android进阶之光|刘望舒|电子工业出版社|<br>|Android Gradle权威指南|飞雪无情|人民邮电出版社|<br>|Kotlin程序开发入门精要|李宁|人民邮电出版社|</p>
<p>我自己觉得做不下去了（很丧）现在的进度非常的慢，我需要停下来学习。我要从SLAM入门开始补充知识==  </p>
<p>我找了我哥一个同学（他曾经搞过SLAM）我把我的思路和已经做的部分告诉了他，他也觉得我需要先把基础知识补一补，他给我推荐了《视觉SLAM十四讲》，<a href="https://github.com/escnqh/Exchange/blob/master/SLAM/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2.rar" target="_blank" rel="external">我花了13个积分从CSDN上找到的高清PDF在这里</a>。下回把我的读书笔记也整理一下发上来。  </p>
<p>入坑了入坑了。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在你的Android项目中使用cpp/cpp第三方库]]></title>
      <url>/2017/10/10/%E5%9C%A8%E4%BD%A0%E7%9A%84Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8cpp%E6%88%96cpp%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>今天终于跑完了Google协同育人项目的协议签署，茫然四顾发现自己在一个巨坑之中==<br>这段时间要加班加点学习NDK学习混编，我的初步的思路是利用orb-SLAM算法进行建模，拿到模型再做其他的都好说，好歹是一个开始，要接着往前走。<br>下面就开始将我学习的过程中一些笔记和心得记录下来。</p>
<p></p><h2>相关概念</h2><br>首先我们要使用的工具是NDK<br>使用<code>Android NDK</code>可以构建任何一段原生代码将其与Android应用一起打包。<p></p>
<p></p><h3>什么是NDK</h3><br>Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C/C++的动态库，并能自动将so和java一起打包成apk。<br>详情查看官方文档：<a href="https://developer.android.com/ndk/index.html" target="_blank" rel="external">https://developer.android.com/ndk/index.html</a><br>（实际上Android Developer官方提供的只有<code>Android.mk</code>和<code>Application.mk</code>对项目构建的方法==，后面再仔细叙述）<p></p>
<p>而使用java原生接口（<code>JNI</code>，<code>Java Native Interface</code>）可以实现java应用程序和原生代码之间的通信。</p>
<p></p><h3>什么是JNI</h3><br>Java Native Interface（JNI）标准是java平台的一部分，JNI是Java语言提供的Java和C/C++相互沟通的机制，Java可以通过JNI调用C/C++代码，C/C++的代码也可以调用java代码。<p></p>
<pre><code>我们主要说说在项目中使用java调用cpp的方法
</code></pre><p>想要用java调用cpp首先要解决的一个问题是，必须要让cpp函数按着命名规则来。<br>命名规则为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">返回值 Java_包路径_类名_函数名(JNIEnv* env,jobject obj);</div></pre></td></tr></table></figure>
<p>对应如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">jint <span class="title">Java_com_ndk_testndk_TestHello_jnia</span><span class="params">(JNIEnv* env,jobject obj)</span></span>;</div></pre></td></tr></table></figure></p>
<p>其中第二个参数为该类的对象，也就是TestHello的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHello</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">jnia</span><span class="params">()</span></span>;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        <span class="comment">// 加载libAppConfig.so库文件  </span></div><div class="line">        <span class="comment">// AppConfig是添加 Android Native Support时输入的名称  </span></div><div class="line">        <span class="comment">// 另外，通过修改Android.mk中的LOCAL_MODULE可以修改这个名称  </span></div><div class="line">        System.loadLibrary(<span class="string">"TestNDK"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++代码  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string h=""&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni h=""&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android log="" h=""&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TestNDK.h"</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  <span class="comment">//最好有这个，否则被编译器改了函数名字找不到不要怪我  </span></span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line"><span class="function">jint <span class="title">Java_com_ndk_testndk_TestHello_jnia</span><span class="params">(JNIEnv* env,jobject obj)</span></span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="number">12</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></div><div class="line">&#125;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p></p><h3>JNI与NDK的关系</h3><br>NDK可以为我们生成了C/C++的动态链接库，JNI是java和C/C++沟通的接口，两者与android没有半毛钱关系，只因为安卓是java程序语言开发，然后通过JNI又能与C/C++沟通，所以我们可以使用NDK+JNI来实现“Java+C”的开发方式。<p></p>
<p></p><h3>为什么要NDK开发</h3><br>NDK开发具有以下优点：<p></p>
<ol>
<li>项目需要调用底层的一些C/C++的一些东西（java无法直接访问到操作系统底层（如系统硬件等）），或者已经在C/C++环境下实现了功能代码（大部分现存的开源库都是用C/C++代码编写的。），直接使用即可。NDK开发常用于驱动开发、无线热点共享、数学运算、实时渲染的游戏、音视频处理、文件压缩、人脸识别、图片处理等。</li>
<li>为了效率更加高效些。将要求高性能的应用逻辑使用C/C++开发，从而提高应用程序的执行效率。但是C/C++代码虽然是高效的，在java与C/C++相互调用时却增大了开销；</li>
<li>基于安全性的考虑。防止代码被反编译，为了安全起见，使用C/C++语言来编写重要的部分以增大系统的安全性，最后生成so库（用过第三方库的应该都不陌生）便于给人提供方便。（任何有效的代码混淆对于会smail语法反编译你apk是分分钟的事，即使你加壳也不能幸免高手的攻击）</li>
<li>便于移植。用C/C++写得库可以方便在其他的嵌入式平台上再次使用。</li>
</ol>
<p></p><h3>什么是CMake</h3><br>脱离 Android 开发来看，c/c++的编译文件在不同平台是不一样的。Unix下会使用<code>makefile</code>文件编译，Windows下会使用 project 文件编译。而<code>CMake</code>则是一个跨平台的编译工具，它并不会直接编译出对象，而是根据自定义的语言规则（<code>CMakeLists.txt</code>）生成对应<code>makefile</code>或<code>project</code>文件，然后再调用底层的编译。<p></p>
<p>在Android Studio 2.2 之后，工具中增加了<code>CMake</code>的支持，你可以这么认为，在 Android Studio 2.2 之后你有2种选择来编译你写的c/c++代码。一个是<code>ndk-build</code>+<code>Android.mk</code>+<code>Application.mk</code>组合，另一个是<code>CMake</code>+<code>CMakeLists.txt</code>组合。这2个组合与Android代码和c/c++代码无关，只是不同的构建脚本和构建命令。<br>更多详细的参见<a href="https://developer.android.com/studio/projects/add-native-code.html" target="_blank" rel="external">AndroidStudio官方文档</a>。</p>
<p></p><h3>ABI是什么</h3><br><code>ABI</code>（Application binary interface）应用程序二进制接口。不同的CPU 与指令集的每种组合都有定义的 ABI (应用程序二进制接口)，一段程序只有遵循这个接口规范才能在该 CPU 上运行，所以同样的程序代码为了兼容多个不同的CPU，需要为不同的 ABI 构建不同的库文件。当然对于CPU来说，不同的架构并不意味着一定互不兼容。<p></p>
<pre><code>armeabi设备只兼容armeabi；//默认都是这个，大多数的Android手机

armeabi-v7a设备兼容armeabi-v7a、armeabi；

arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；

X86设备兼容X86、armeabi；

X86_64设备兼容X86_64、X86、armeabi；

mips64设备兼容mips64、mips；

mips只兼容mips；
</code></pre><p></p><h2>通过一个例子来说明</h2><br><a href="https://github.com/escnqh/PracticeProject4NDK.git" target="_blank" rel="external">github仓库链接</a><br>我在这个例子里自己模拟了一个cpp写的第三方库，通过NDK打包成apk，在CPP和java之间使用JNI层来调用Cpp库中的方法；并且配置了<code>Gradle</code>和<code>Cmakelist</code>.<br>在这个项目里，我通过项目本身的示例作用和一些注释，标注了一些容易出现问题的地方和值得注意的地方。<br>详细的问题还是看项目吧。<p></p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新思路团队Android小组技术栈]]></title>
      <url>/2017/09/17/Newthread_Android%E5%B0%8F%E7%BB%84%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      <content type="html"><![CDATA[<p></p><h2>一、  基础篇</h2><p></p>
<p></p><h3>1、Android Studio 熟练使用：包括环境的配置和编译器的使用</h3><p></p>
<p></p><h4>1.1 AndroidStudio环境配置</h4><br>（1） jdk下载和环境配置<br>下载网址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>环境配置：<br>jdk8会自动配置环境变量，在cmd中输入javac可查看是否已经成功配（如若未自动设置环境变量，自行百度设置方法）<br>（2） AndroidStudio下载<br>中文社区：<br><a href="http://www.android-studio.org/" target="_blank" rel="external">http://www.android-studio.org/</a><br>官网（需要翻墙）：<br><a href="http://developer.android.com/studio/index.html" target="_blank" rel="external">http://developer.android.com/studio/index.html</a><p></p>
<p></p><h4>1.2 AndroidStudio的使用</h4><br>（1） AndroidSDK下载<br>（2） AndroidStudio常用快捷键的使用<br>（3） 在AndroidStudio中使用git进行版本控制以及利用github实现远程仓   库使用和项目分支管理<br>（4） 在AndroidStudio中安装插件<p></p>
<p></p><h3>2、Android四大组件：</h3><p></p>
<p></p><h4>2.1 Activity</h4><br>（1） 什么是Activity？<br>（2） 在AndroidManifest.xml中配置Activity<br>（3） Activity的生命周期<br>（4） 启动Activity的两种方法：startActivity()和startActivityForResult()使用区别<br>（5） 退出Activity的方式：onBackgress()和finsh()的异同<br>（6） 使用Bundle在Activity之间交换数据<p></p>
<p></p><h4>2.2 Service</h4><br>（1） 创建和配置Service<br>（2） Service的生命周期<br>（3） 启动Service的方法：startService()和bindService()的使用区别<br>（4） 本地Service的绑定和通信<br>（5） 怎么保证service不被kill<p></p>
<p></p><h4>2.3 Broadcast Receiver</h4><br>创建和配置BroadcastReceiver组件<p></p>
<p></p><h4>2.4 Content Provider</h4><br>ContentProvider配置和调用<p></p>
<p></p><h3>3、Intent使用</h3><p></p>
<p></p><h4>3.1 显式和隐式Intent</h4><br>（1） 显式Intent的使用方法<br>（2） 隐式Intent的使用方法：使用category、setData()实现启动自己程序内的活动或启动其他程序的活动<p></p>
<p></p><h4>3.2 使用Intet运用手机多媒体，比如调用系统摄像头、相册、照片裁剪器等</h4><p></p>
<p></p><h4>3.3 使用Intet传递或返回数据</h4><br>（1） 传递数据和接收数据的方式<br>（2） 使用Intent传递数据大小限制，不要使用Bundle传递大容量数据<br>注：intent API中文翻译：<a href="http://www.oschina.net/question/565065_67909" target="_blank" rel="external">http://www.oschina.net/question/565065_67909</a><p></p>
<p></p><h3>4、常见控件和布局的使用</h3><p></p>
<p></p><h4>4.1 基本布局：LinearLayout、RelativeLayout、FrameLayout、TableLayout</h4><p></p>
<p></p><h4>4.2 常见控件：</h4><br>（1） TextView、EditText：文本显示和文本输入<br>（2） ImageView：图片显示控件<br>（3） Button和ImageButton：设置监听的两种方式（布局中设置和代码中设置）<br>（4） Progress、Dialog、PopupWindow：实现弹窗<br>（5） ListView和RecyclerView：Adpter加载列表<br>（6） SwipeRefreshLayout：实现下拉刷新<br>（7） ScrollView、NestedScrollView：实现屏幕滑动和滑动监听<p></p>
<p></p><h3>5、数据存储：</h3><p></p>
<p></p><h4>5.1 掌握SharedPreferences存储的存储和查询数据方式。</h4><p></p>
<p></p><h4>5.2 了解使用SQLite进行数据库的创建、升级以及数据的添加、查询、删除、更新等功能。</h4><p></p>
<p></p><h4>5.3 文件存储</h4><p></p>
<p></p><h3>6、基本的网络访问技术：</h3><p></p>
<p></p><h4>6.1 HttpURLConnection，学会调用API</h4><p></p>
<p></p><h4>6.2 使用JSONObject解析JSON数据</h4><p></p>
<p></p><h4>6.3 线程的简单理解和使用</h4><p></p>
<p></p><h3>7、学习Python：</h3><p></p>
<p></p><h4>7.1 Python的基本数据类型和语法</h4><p></p>
<p></p><h4>7.2 函数的定义和调用</h4><p></p>
<p></p><h4>7.3 Python语言的高级特性</h4><br>注：还有python里的面向对象编程，函数式编程、进程和线程都可以参照Java语言来学习。参考学习网站：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a><p></p>
<p>该阶段推荐书籍资料：《第一行代码》、《疯狂Android讲义》、《Python基础教程》</p>
<p></p><h2>二、提高篇</h2><p></p>
<p></p><h3>1、UI进阶</h3><p></p>
<p></p><h4>1.1 Fragment</h4><br>（1） 什么是Fragment?<br>（2） Fragment的生命周期<br>（3） Fragment与Activity之间的通信<br>（4） Fragment的管理，包括fragment的hide、show和add方法的理解，以及对fragment栈的掌握<p></p>
<p></p><h4>1.2 Viewpager</h4><br>（1） 掌握Viewpager的adapter的构造<br>（2） 学会viewpager和底部Tab栏的结合使用<p></p>
<p></p><h4>1.3 Android中常用动画有哪两类，各自的特点</h4><br>（1） 补间动画<br>（2） 属性动画<p></p>
<p></p><h4>1.4 自定义View，重点View绘制的几个方法</h4><br>（1） 自定义View的属性<br>（2） 在View的构造方法中获得我们自定义的属性<br>（3） 重写onDraw，onMesure方法<p></p>
<p></p><h4>1.5 View的事件分发机制</h4><br>（1） 点击事件的传递机制<br>1)  什么是事件序列<br>2)  点击事件的传递顺序<br>3)  分发事件的三个重要方法<br>（2） 分析源码，根据view点击事件实例学习<p></p>
<p></p><h4>1.6 Materail Design设计：</h4><br>掌握MD设计思想，以及MD风格的控件和布局的使用<p></p>
<p></p><h3>2、Android进阶知识储备</h3><p></p>
<p></p><h4>2.1  Activity的四种启动模式和特点：</h4><br>（1） standard<br>（2） singleTop<br>（3） singleTask<br>（4） singleInstance<p></p>
<p></p><h4>2.2  掌握activity返回栈的工作原理</h4><p></p>
<p></p><h4>2.3  Broadcast Receiver</h4><br>（1） Android常见广播Action常量<br>（2） Service的启动方法<p></p>
<p></p><h4>2.4  Content Provider</h4><br>（1） Uri是什么，Url是什么（二者不可混淆）<br>（2） 什么是ContentProvider，完整开发一个ContentProvider的步骤<br>（3） 使用ContentProvider操作数据<br>（4） ContentProvider子类开发：实现query()，insert()，update()，delete()方法，AndroidManifest.xml注册<br>（5） 操作系统的ContentProvider<p></p>
<p></p><h4>2.5  Android IPC机制</h4><br>（1） 什么是进程，什么是线程，什么是多进程模式<br>（2） Binder的工作机制<br>（3） Android中如何实现进程间通信<p></p>
<p></p><h4>2.6  Android多线程编程</h4><br>（1） 理解异步消息处理机制，重点Message、Handler、MessageQueue、Looper的工作原理。<br>（2） 掌握AsyncTask的使用<p></p>
<p></p><h4>2.7  OkHttp、Retrofit实现网络访问：</h4><br>（1） 了解Http的基础知识，包括请求/相应报文格式、header和请求体的三种形式（参考网站：<a href="http://www.jianshu.com/p/e544b7a76dac" target="_blank" rel="external">http://www.jianshu.com/p/e544b7a76dac</a>）。<br>（2） 学会使用OkHttp，并了解其中的原理。<br>（3） 熟悉Retrofit，探索与OkHttp之间的关系。<p></p>
<p></p><h4>2.8  使用GSON解析数据</h4><p></p>
<p></p><h4>2.9  Intent传递对象的两种方式及原理： </h4><br>（1） Serializable方式<br>（2） Parcelable方式<p></p>
<p></p><h4>2.10  Android中的权限管理和运行时权限机制：</h4><br>（1） 权限分类、授权机制<br>（2） 申请权限及权限回调<p></p>
<p></p><h3>3、Android中的代码设计思想</h3><p></p>
<p></p><h4>3.1 设计模式</h4><br>（1） 什么是设计模式：<br>（2） Android开发中常见的设计模式有23种：<br>1)  创建型模式5种：单例模式，抽象工厂模式，工厂模式，原型模式，建造者模式。<br>2)  结构型模式7种：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。<br>3)  行为型模式11种：观察者模式，中介者模式，访问者模式，解释器模式，迭代器模式，备忘录模式，责任链模式，状态模式，策略模式，命令模式，模板模式。<br>（3） 重点掌握：<br>1)  单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>2)  工厂模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。<br>3)  建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>4)  观察者模式：一个对象发生改变时，所有信赖于它的对象自动做相应改变。<p></p>
<p></p><h4>3.2 RxJava</h4><br>（1） 什么是RxJava<br>（2） 简单了解RxJava的适用场景和使用方式<br>（3） 重点掌握与Retrofit的结合，用此示例来学习。<p></p>
<p></p><h4>3.3 接口回调机制：</h4><br>（1） 回调函数<br>（2） 可根据view的点击事件理解接口回调机制<p></p>
<p></p><h4>3.4 Android中的弱引用和软引用：</h4><br>（1） 弱引用的应用环境<br>（2） 软引用的应用环境<br>（3） 软引用与弱引用的区别<p></p>
<p>该阶段推荐书籍资料：《Android开发艺术探索》、《设计模式之禅》、《Android源码设计模式解析与实战》、《Android群英传》、《Java核心技术》</p>
<p></p><h2>三、竞赛篇</h2><p></p>
<ol>
<li>Android项目架构模式：MVC、MVP、MVP-RxJava、MVP-databinding等等</li>
<li>熟悉各种常用API调用：百度或者高德地图等</li>
<li>了解各种开源框架：LitePal、Picasso、Glide等（开源框架作用仅限缩短开发周期，所以重要的还是学习其中的原理）</li>
<li>熟练Git操作，利用GitHub或者Coding管理代码仓库</li>
</ol>
<p>版本号 修订人 修订日期    修订描述<br>1.0 2015级Android组成员 2017.09.14  创建</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[观察者模式的学习和应用]]></title>
      <url>/2017/08/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>停了有些日子没有管我的博客，这段时间经历了<code>期末考试</code>和<code>服务外包</code>的比赛。今天刚刚结束，刚从武汉回到家里休息了一天，今天早上还约了人来把家里的光纤修好了。现在可以好好整理一下在比赛时候的一些小小的总结。这次的比赛收获的更多是一种应用和熟练，把自己之前学过的一些知识得以运用（才发现是如此的生疏。和队友的构想，讨论，舍弃太自我的想法，长时间的配合和解决一个一个问题，熬过一个一个夜，慢慢整理出的作品。也算是费尽一番心血。</p>
<p>这篇博客就选取其中的一点心得作为记录，作为对<code>观察者模式</code>的学习和应用总结。</p>
<h2>何为观察者模式</h2>

<pre><code>观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。
</code></pre><p>它将观察者和被观察者的对象分离开。提高了应用程序的可维护性和重用性。</p>
<p>实现观察者模式有很多形式，一种是“注册—通知—撤销注册”的形式。</p>
<p><code>观察者Observer：</code>所有潜在的观察者必须实现观察者接口，这个接口只有update方法，当主题改变时，它被调用。<br><code>具体观察者ConcreteObserver:</code> 具体观察者可以是任何实现了Observer接口的类。观察者必须注册具体主题，一边接收更新。<br><code>可观察者Subject:</code> 主题接口，即可观察者Observable，对象使用此接口注册为观察者，或者把自己从观察者中删除，每个主题可以有多个观察者。<br><code>具体可观察者ConcreteSubject:</code> 一个具体主题实现了主题接口，除了注册和撤销之外，具体主题还实现了notifyObservers()方法，这个方法用来在主题状态改变时更新所有观察者。具体主题也可能有设置和获取状态的方法。<br><img src="/images/20170829180613.jpg" alt="类图"><br>常见的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temprature)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span><span class="params">(<span class="keyword">final</span> Subject subject)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">        <span class="keyword">this</span>.subject.registerObserver(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> temperature)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> temperature)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observer&gt; observers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">temperatureChanged</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(<span class="keyword">final</span> <span class="keyword">float</span> temperature)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">        <span class="keyword">this</span>.temperatureChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteSubject</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(<span class="keyword">final</span> Observer o)</span></span></div><div class="line">    &#123;</div><div class="line">        observers.add(o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="keyword">final</span> Observer o)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (observers.indexOf(o) &gt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            observers.remove(o);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Observer o : observers)</div><div class="line">        &#123;</div><div class="line">            o.update(temperature);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">final</span> ConcreteSubject sb = <span class="keyword">new</span> ConcreteSubject();</div><div class="line">        sb.setTemperature((<span class="keyword">float</span>) <span class="number">20.00</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Observer o = <span class="keyword">new</span> ConcreteObserver(sb);</div><div class="line">        sb.setTemperature((<span class="keyword">float</span>) <span class="number">21.00</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 观察者模式的应用场景：</p>
<p>1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。</p>
<p>2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。</p>
<p>观察者模式的优点：</p>
<p>1、 Subject和Observer之间是松偶合的，分别可以各自独立改变。</p>
<p>2、 Subject在发送广播通知的时候，无须指定具体的Observer，Observer可以自己决定是否要订阅Subject的通知。</p>
<p>3、 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。</p>
<p>观察者模式的缺陷：</p>
<p>1、 松偶合导致代码关系不明显，有时可能难以理解。(废话)</p>
<p>2、 如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。（毕竟只是简单的遍历）</p>
<p></p><h2>为何使用观察者模式</h2><br>在进行<code>校园广播</code>项目的时候，我遇到了一个问题，那就是我自定义实现了一个<code>Dialog</code>，这个<code>Dialog</code>用来展示举报界面并且携带信息返回。我要在<code>Dialog</code>show之后拿到返回的值，但是由于时间上的异步性，我没有办法准确的控制好时间，等待信息返回之后再进行别的操作，于是乎这个时间差我只能够通过一个简化的观察者模式来解决。<p></p>
<p>我的思路就是利用自定义Dialog类中的接口定义拿的这个步骤，通过这个接口传递信息。在目标类实现这个接口中拿的操作，通过监听使得可观察者在信息改变时获取到改变。</p>
<p>废话少说，具体代码在下面，通过一个简化过的观察者模式（伪）的例子来了解我的方法。</p>
<p></p><h2>一个简化的例子</h2><br>自定义<code>Dialog</code>：<p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportDialog</span> </span>&#123;</div><div class="line"></div><div class="line">    Context act = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">7</span>;</div><div class="line">    <span class="keyword">private</span> ReportResult reportResult;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReportDialog</span><span class="params">(Context act)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.act = act;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(act);</div><div class="line">        builder.setTitle(<span class="string">"选择一项举报该电台:"</span>);</div><div class="line">        builder.setIcon(R.drawable.report_icon);</div><div class="line">        <span class="keyword">final</span> String[] items = <span class="keyword">new</span> String[]&#123;<span class="string">"含有暴力色情等内容。"</span>, <span class="string">"言论有不当、虚假内容。"</span>, <span class="string">"含有引起不适的内容。"</span>&#125;;</div><div class="line">        builder.setSingleChoiceItems(items,<span class="number">3</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;<span class="comment">/*设置单选条件的点击事件*/</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                result = which;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        builder.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                Toast.makeText(act, <span class="string">"感谢您的举报~"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                reportResult.getResult(result);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        builder.setNegativeButton(<span class="string">"CANCEL"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                Toast.makeText(act, <span class="string">"举报取消啦~"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">                result = <span class="number">7</span>;</div><div class="line">                reportResult.getResult(result);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        builder.setCancelable(<span class="keyword">false</span>);</div><div class="line">        builder.show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReportResult</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> result)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReportResultListener</span><span class="params">(ReportResult reportResult)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.reportResult=reportResult;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的实现类部分：<br>（一部分是使用retrofit2和后台进行交互）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> <span class="keyword">implements</span> <span class="title">ReportDialog</span>.<span class="title">ReportResult</span> </span>&#123;</div><div class="line"></div><div class="line">       Context context;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Report</span><span class="params">(Context context, View v)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.context = context;</div><div class="line">           ReportDialog reportDialog = <span class="keyword">new</span> ReportDialog(context);</div><div class="line">           reportDialog.show(v);</div><div class="line">           reportDialog.getReportResultListener(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> (result != <span class="number">7</span>) &#123;</div><div class="line">               Date now = <span class="keyword">new</span> Date();</div><div class="line">               <span class="keyword">long</span> nowtime = now.getTime();</div><div class="line">               ReportApi reportApi = <span class="keyword">new</span> ReportApi();</div><div class="line">               ReportService reportService = reportApi.getService();</div><div class="line">               ReportBean reportBean = <span class="keyword">new</span> ReportBean();</div><div class="line">               reportBean.setChannelID(channelId);</div><div class="line">               reportBean.setEvent(result);</div><div class="line">               reportBean.setTime(nowtime);</div><div class="line">               reportBean.setUserID(channelHostId);</div><div class="line">               Gson gson = <span class="keyword">new</span> Gson();</div><div class="line">               <span class="keyword">final</span> RequestBody requestBody = RequestBody.create(MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>), gson.toJson(reportBean));</div><div class="line">               Call&lt;isTrueBean&gt; call_beginBroadcast = reportService.getState(requestBody);</div><div class="line">               call_beginBroadcast.enqueue(<span class="keyword">new</span> Callback&lt;isTrueBean&gt;() &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;isTrueBean&gt; call, Response&lt;isTrueBean&gt; response)</span> </span>&#123;</div><div class="line">                       <span class="keyword">if</span> (response.body() != <span class="keyword">null</span>) &#123;</div><div class="line">                           <span class="keyword">int</span> result = response.body().getSign();</div><div class="line">                           <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</div><div class="line">                               Log.i(TAG, <span class="string">"举报成功"</span>);</div><div class="line">                           &#125; <span class="keyword">else</span> &#123;</div><div class="line">                               Log.i(TAG, <span class="string">"举报失败"</span>);</div><div class="line">                           &#125;</div><div class="line">                       &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           Log.i(TAG, <span class="string">"举报返回空"</span>);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;isTrueBean&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">                       Log.i(TAG, <span class="string">"举报返回失败"</span>);</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这样应该很明显的看我是用什么方法解决了问题的。可能跟经典的的观察者模式有些出入，但是达到了实际需要的效果。</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XML复习知识总结]]></title>
      <url>/2017/06/12/XML%E5%A4%8D%E4%B9%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2>java开发工具的使用</h2>

<ul>
<li>Intellij IDEA环境使用</li>
<li>Tomcat使用</li>
</ul>
<p></p><h2>xml：平台语言沟通的桥梁</h2><p></p>
<h3>校验：</h3><br>使用浏览器<br><h3>xml语法：</h3>

<pre><code>XML（eXtensible Markup Language）,可扩展标记语言。“可扩展”，即用户可以自定义标记。
</code></pre><p><img src="/images/20170612132124.jpg" alt="此处输入图片的描述"></p>
<ol>
<li>文档声明：<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;  standalone=&quot;yes&quot; ?&gt;</code><br>XML是一种元语言。<code>&lt;?xml version=“1.0”?&gt;</code>书写xml文件应注意：xml声明语句必须作为文件的第一行；</li>
<li>根标记：<br>xml有且仅有一个跟标记，其他标记必须封装在根标记中，文件的标记必须形成树状结构；</li>
<li>规范的XML：符合W3C制定的规则；</li>
<li>xml和HTML的主要区别：<br>① HTML的标记是固定的，预定义的，不可扩展的；而XML的标记是可扩展的，是可以由用户自定义的；<br>② HTML的标记说明了信息的显示格式；而XML标记表示了数据的逻辑结构及语义；</li>
<li>字符集(Charset)：<br>一组抽象字符的集合。其中字符(Character)是文字与符号的总称，包括文字、图形符号、数学符号等。英文字符集、繁体汉字字符集、日文汉字字符集；<br>被编码过的字符集(Coded Character Set) ：每种编码都限定了一个明确的字符集合；</li>
<li>ASCII：<br>美国信息交换标准码； ISO 8859，全称ISO/IEC 8859: ISO8859-1；</li>
<li>Unicode:<br>UTF-8,Unicode转换格式（Unicode Translation Format，简称UTF）；<br>Unicode的实现方式不同于编码方式。 Unicode的实现方式称为Unicode转换格式(UnicodeTranslationFormat，简称为UTF)。一个字符的Unicode编码是确定的，但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，Unicode编码的实现方式就有所不同。</li>
<li>UTF-8:大多数常用字符(ASCII中0～127字符)它只使用单字节，而对其它常用字符(特别是朝鲜和汉语会意文字)，它使用3字节；</li>
<li>汉字编码：<br>GB2312、BIG5；<br>GB2312：简体中文字符集，全称为GB2312(80)字符集，共包括国标简体汉字6763个<br>ANSI:美国国家标准局</li>
<li><code>&lt;?xml version=“1.0”encoding=“UTF-8”?&gt;</code>以“UTF-8”编码保存 默认；<br><code>&lt;?xml version=“1.0”encoding=“gb2312”?&gt;</code>以“ANSI”编码保存 ASCII、汉字；<br><code>&lt;?xml version=“1.0”encoding=“ISO-8859- 1”?&gt;</code>以“ANSI”编码保存ASCII；</li>
<li><code>&lt;!--此处为注释信息--&gt;</code>注释根标记</li>
<li>标记的命名规则：<br>必须以字母、下划线(_)或冒号(:)开头；<br>后面可以跟有效的名字符，有效名字符除了前面的，还包含数字、连接符(-)、句点(.)；<br>英文字母大小写敏感的；<br>名称不能含有空格；<br>名称中不能有字符串“xml”，“XML”或以任何顺序排列的这三个字母的组合。W3C保留对三个字母的命名的使用权；</li>
<li>五种特殊字符：<br>“ &lt; ”、“ &gt; ”、“ &amp; ”、“ ‘ ”、“ “ ”；<br>&amp;lt &lt;；&amp;gt &gt;；&amp;amp &amp;;&amp;apos ‘；&amp;quot “;</li>
<li>以“<code>&lt;![CDATA[</code>”作为段开始，以“<code>]]&gt;</code>”作为段结束，段开始和段结束之间称为CDATA段的内容。<br>CDATA段中的内容可以包含任意的字符。<br>标记内容可以由两个部分构成：文本数据部分和子标记部分。 一个标记的文本数据包括：普通字符、<br>CDATA段的内容、字符引用和实体引用。</li>
<li>名称空间：有效区分名字相同的标记；<br>名称空间声明有两种形式：<br>有前缀名称空间 ：<code>xmlns：person=“2203026”</code>；<br>无前缀名称空：<code>xmlns=“www.tup.com”</code>;<br>当且仅当它们的名字相同时称两个名称空间相同; URI只是形式上的标识符，唯一的目的是提供一个唯一的名字，并不需要指向一个有效的内容，在URI所标识的位置上，可以不存在任何东西。</li>
<li>URI（Uniform Resource Identifier），作为名称空间的名字。名称空间的名字不必是有效的，它仅仅是为了区分名称空间的名字而已;</li>
<li><p>名称空间的引用<br>（1）有前缀的名称空间：在开始标记和结束标记的名字前面添加名称空间的前缀和冒号来引用名称空间;<br>（2）无前缀的名称空间：该标记及其子标记都默认地隶属于这个名称空间;<br>（3）无前缀的名称空间：子标记也可以重新声明名称空间。</p>
<h3>xml约束：</h3>
</li>
<li><p>DTD约束：（内部约束，外部约束）<br>内部约束：直接写在xml文档中</p>
</li>
</ol>
<blockquote>
<pre><code>&lt;?xml version=”1.0” encoding=”gbk”?&gt;
&lt;!DOCTYPE 书架（根元素）[
    &lt;!ELEMENT 书架 (书+)&gt;//根元素包含的子元素书最少一个
    &lt;!ELEMENT 书 (书名,作者,售价)&gt;//子元素必须包含的子标签
    &lt;!ELEMENT 书名 (#PCDATA)&gt;//PCDATA表示元素的主体内容为普通文本
    &lt;!ELEMENT 作者 (#PCDATA)&gt;
    &lt;!ELEMENT 售价 (#PCDATA)&gt;         
]&gt;
&lt;书架&gt;
</code></pre></blockquote>
<p>外部约束：外部引入.dtd作为单独的文件存在。文件扩展名.dtd,文件必须用UTF-8编码保存到磁盘上</p>
<blockquote>
<pre><code>//dtd文件在本地：
&lt;!DOCTYPE 根元素 SYSTEM  “dtd文件的地址”&gt;
//dtd文件在外地（网上）：
&lt;!DOCTYPE 根元素 PUBLIC “dtd的名称” “dtd的路径”&gt;
//示例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt;
&lt;!DOCTYPE TVSCHEDULE SYSTEM &quot;tet.dtd&quot;&gt;
&lt;TVSCHEDULE NAME=&quot;CCTV&quot;&gt;
    &lt;CHANNEL CHAN=&quot;zh&quot;&gt;
        &lt;BANNER&gt;文本&lt;/BANNER&gt;
        &lt;DAY&gt;
            &lt;DATE&gt;文本&lt;/DATE&gt;
            &lt;HOLIDAY&gt;文本&lt;/HOLIDAY&gt;
        &lt;/DAY&gt;
        &lt;DAY&gt;
            &lt;DATE&gt;文本&lt;/DATE&gt;
            &lt;PROGRAMSLOT&gt;
                &lt;TIME&gt;文本&lt;/TIME&gt;
                &lt;TITLE&gt;文本&lt;/TITLE&gt;
                &lt;DESCRIPTION&gt;文本&lt;/DESCRIPTION&gt;
            &lt;/PROGRAMSLOT&gt;
        &lt;/DAY&gt;
    &lt;/CHANNEL&gt;
&lt;/TVSCHEDULE&gt;
</code></pre></blockquote>
<p><strong><em>DTD语法：</em></strong><br><em>DTD的基本结构</em>：① DTD的开始标记定义元素，这是DTD中最主要注释；② 定义元素属性；<br><em>XML与DTD的关联</em>：外部DTD关联形式<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;</code>私有DTD引用<code>&lt;!DOCTYPE 根元素名SYSTEM  “DTD文件的URI&quot;&gt;</code>；<br><em>公共DTD引用</em>：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;</code> <code>&lt;!DOCTYPE 根元素名PUBLIC“DTD名称” “DTD文件的URI&quot;&gt;</code><br><strong><em>用脚本校验xml是否符合DTD约束</em></strong></p>
<ol>
<li>Schema<br>Schema语法（会读就可以）<br>名称空间，著名名称空间<br><img src="/images/20170612172737.jpg" alt="此处输入图片的描述"><br><h3>xml解析：</h3><br>程序对xml的读写，生成相应的对象<br>dom解析：只需解析一次，生成对象，但加载完整的树之后才开始解析<br>—dom4j案例</li>
</ol>
<blockquote>
<pre><code>//xml文本
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;State Code=&quot;37&quot; Name=&quot;山东&quot; description=&quot;省会&quot;&gt;
    &lt;City&gt;
        &lt;Name&gt;济南&lt;/Name&gt;
        &lt;Region&gt;历下区&lt;/Region&gt;
    &lt;/City&gt;
    &lt;City&gt;青岛&lt;/City&gt;
    &lt;City&gt;威海&lt;/City&gt;
    &lt;City&gt;泰安&lt;/City&gt;
&lt;/State&gt;
</code></pre></blockquote>
<pre><code>import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class JaxpDemo {
    public static void main(String[] args) throws Exception {   
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();//得到创建解析器的工厂：DocumentBuilderFactory
        DocumentBuilder builder = factory.newDocumentBuilder();//通过工厂得到解析器：DocumentBuilder
        Document document = builder.parse(&quot;xml文件路径&quot;);//加载xml文件：得到了Document对象    
    }
    public static void test1(Document document){//得到某个具体的节点内容
        NodeList nl = document.getElementsByTagName(&quot;City&quot;);//得到所有的City元素，
        Node node = nl.item(2);//索引从0开始
        System.out.println(node.getTextContent());//打印获得节点的主体内容
    }
    public static void test2(Document document){//遍历所有元素节点。
        Node rootNode = document.getElementsByTagName(&quot;State&quot;).item(0);
        treewalk(rootNode);
    }
    public static void treewalk(Node node){//递归
        if(node.getNodeType()==Node.ELEMENT_NODE){//是一个元素节点
            System.out.println(node.getNodeName());//打印元素的名称
        }
        NodeList nl = node.getChildNodes();//看看他有没有孩子
        for(int i=0;i&lt;nl.getLength();i++){
            Node n = nl.item(i);
            treewalk(n);//递归
        }
    }
    public static void test3(Document document) throws Exception{//修改某个元素节点的主体内容
        Node secondCityNode = document.getElementsByTagName(&quot;City&quot;).item(1);//找到第2个City元素
        secondCityNode.setTextContent(&quot;威海&quot;);//设置主体内容为：威海
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test4(Document document) throws Exception{//向指定元素节点中增加子元素节
        Element e = document.createElement(&quot;City&quot;);//&lt;City&gt;&lt;/City&gt;//创建新元素
        e.setTextContent(&quot;烟台&quot;);//&lt;City&gt;烟台&lt;/City&gt;
        Node rootNode = document.getElementsByTagName(&quot;State&quot;).item(0);
        rootNode.appendChild(e);//把新元素添加到State最后
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test5(Document document) throws Exception{//向指定元素节点上增加同级元素节点
        Element e = document.createElement(&quot;City&quot;);//创建新元素
        e.setTextContent(&quot;青岛&quot;);
        //调用inertBefore插入新节点：必须由父节点来调用
        Node secondNode = document.getElementsByTagName(&quot;City&quot;).item(1);
        secondNode.getParentNode().insertBefore(e, secondNode);
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test6(Document document) throws Exception{//删除指定元素节点
        Node ytNode = document.getElementsByTagName(&quot;City&quot;).item(4);//得到烟台节点
        ytNode.getParentNode().removeChild(ytNode);//用父节点删除 
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test7(Document document) throws Exception{//操作XML文件属性
        Node stateNode = document.getElementsByTagName(&quot;State&quot;).item(0);//看成元素
        if(stateNode.getNodeType()==Node.ELEMENT_NODE){
            Element e = (Element)stateNode;
            System.out.println(e.getAttribute(&quot;Name&quot;));
        }
    }
    public static void test8(Document document) throws Exception{//8、添加属性
        Node stateNode = document.getElementsByTagName(&quot;State&quot;).item(0);//看成元素
        if(stateNode.getNodeType()==Node.ELEMENT_NODE){
            Element e = (Element)stateNode;
            e.setAttribute(&quot;description&quot;, &quot;省会&quot;);
        }
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 技术笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> XML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用OkHttp]]></title>
      <url>/2017/06/11/%E4%BD%BF%E7%94%A8OkHttp/</url>
      <content type="html"><![CDATA[<p>首先就是导依赖：</p>
<pre><code>compile &apos;com.zhy:okhttputils:2.0.0&apos;
</code></pre><h2 id="HttpURLConnection和OkHttp的比较"><a href="#HttpURLConnection和OkHttp的比较" class="headerlink" title="HttpURLConnection和OkHttp的比较"></a>HttpURLConnection和OkHttp的比较</h2><pre><code>● HttpURLConnection有的API，OkHttp基本上都有（你有我有全都有呀，哈哈哈）
● HttpURLConnection和OkHttp都支持Https，流的上传和下载，超时，IP6、连接池等等
● OkHttp比HttpURLConnection具有更好的同步异步请求、缓存机制，支持HttpDNS、重定向、Gzip压缩，平台适应性、很好的服务器IP的转换、直接Socket通信，支持拦截器等等。
</code></pre><p>看到这么多机制，是不是觉得很强大，通过Socket直接通信，以及很好的缓存机制，Gzip对于Http头部的压缩传输。自然对于网络请求这块使应用更加省流量、请求的更快。OkHttp对于Https和HttpDNS的支持，使得应用的网络通信安全性更高。当然说了它的好，现在也来说说它的不好之处：</p>
<pre><code>● OkHttp不支持优先级请求
● OkHttp不支持自签名证书
● OkHttp header中不能传中文
</code></pre><p>虽然是不好的地方，但是OkHttp已经比较成熟了，网上解决这几个问题的资料也很多了。所以这些都不是问题。</p>
<h2 id="一个简单的Get请求例子"><a href="#一个简单的Get请求例子" class="headerlink" title="一个简单的Get请求例子"></a>一个简单的Get请求例子</h2><p>这里我们就以经典的官网提供的Get请求的例子来学习下，说大概的代码。<br>  ● 先在manifest加个网络权限，养成良好习惯</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre><p>然后在build.gradle文件的dependencies添加库如下：</p>
<pre><code>dependencies {
    compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos;
    compile &apos;com.squareup.okio:okio:1.7.0&apos;
}
</code></pre><p>同步Get请求：</p>
<pre><code>final OkHttpClient okHttpClient = new OkHttpClient()
           .newBuilder()
           .build();
   final Request request = new Request.Builder()
           .url(&quot;https://www.publicobject.com/helloworld.txt&quot;)
           .header(&quot;User-Agent&quot;,&quot;OkHttp Example&quot;)
           .build();
   new Thread(new Runnable() {
       @Override
       public void run() {
           try {
               Response response = okHttpClient.newCall(request).execute();
               Log.d(&quot;zgx&quot;,&quot;response=====&quot;+response.body().string());
               response.body().close();
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   }).start();
</code></pre><h2 id="一些基本的知识"><a href="#一些基本的知识" class="headerlink" title="一些基本的知识"></a>一些基本的知识</h2><ul>
<li>Http</li>
</ul>
<p>Http是一种基于TCP/IP连接的一套网络通信协议，它是一种一应一答的请求，它分为Get和Post请求，Get请求获取得是静态页面，它可以把参数放在URL字符串后面。而Post请求就不同了，它是把参数放在Http请求的正文的。<br>Get请求我们会这样请求：</p>
<pre><code>private void HttpURLConnection_Get(){  
        try{  
            //通过openConnection 连接  
            URL url = new java.net.URL(URL);  
            urlConn=(HttpURLConnection)url.openConnection();  
            //设置输入和输出流   
            urlConn.setDoOutput(true);  
            urlConn.setDoInput(true);  
            //关闭连接  
            urlConn.disconnect();  
        }catch(Exception e){  
            resultData = &quot;连接超时&quot;;  
        }  
    } 
</code></pre><p>然后把获取到的urlConn连接的数据通过IO流把读取出来：</p>
<pre><code>InputStreamReader in = new InputStreamReader(urlConn.getInputStream());    
                   BufferedReader buffer = new BufferedReader(in);    
                   String inputLine = null;    
                   while (((inputLine = buffer.readLine()) != null)){  
                       resultData += inputLine + &quot;\n&quot;;    
                   }  
                   System.out.println(resultData);  
                   in.close();
</code></pre><p>Post请求则会这样：</p>
<pre><code>private void HttpURLConnection_Post(){  
      try{  
          //通过openConnection 连接  
          URL url = new java.net.URL(URL_Post);  
          urlConn=(HttpURLConnection)url.openConnection();  
          //设置输入和输出流   
          urlConn.setDoOutput(true);  
          urlConn.setDoInput(true);  

          urlConn.setRequestMethod(&quot;POST&quot;);  
          urlConn.setUseCaches(false);  
          // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的    
          urlConn.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    
          // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  
          // 要注意的是connection.getOutputStream会隐含的进行connect。    
          urlConn.connect();  
          //DataOutputStream流  
          DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  
          //要上传的参数  
          String content = &quot;par=&quot; + URLEncoder.encode(&quot;ylx_Post+中正&quot;, &quot;UTF_8&quot;);   
          //将要上传的内容写入流中  
          out.writeBytes(content);     
          //刷新、关闭  
          out.flush();  
          out.close();     

      }catch(Exception e){  
          resultData = &quot;连接超时&quot;;  
      }  
  } 
</code></pre><p>然后同上把获取到的urlConn连接的数据通过IO流把读取出来，大概的代码就是这样。</p>
<ul>
<li>缓存处理</li>
</ul>
<p>先来看看OkHttp的缓存怎么设置</p>
<pre><code>int cacheSize = 10 * 1024 * 1024; // 10 MiB
  //cacheDirectory保存缓存的目录，cacheSize缓存空间的大小
  Cache cache = new Cache(context.getCacheDir(), cacheSize);
  final OkHttpClient okHttpClient = new OkHttpClient()
          .newBuilder()
          .cache(cache)
          .build();
</code></pre>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Retrofit框架]]></title>
      <url>/2017/06/07/%E4%BD%BF%E7%94%A8Retrofit%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>先添加几个权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre><p>build.gradle添加依赖，下面会用到的也在这里了：</p>
<pre><code>compile &apos;com.android.support:appcompat-v7:23.4.0&apos;
compile &apos;com.android.support:design:23.4.0&apos;
compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;
compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;
compile &apos;com.squareup.okhttp3:okhttp:3.3.0&apos;
compile &apos;com.squareup.okio:okio:1.7.0&apos;
 compile &apos;com.squareup.okhttp3:logging-interceptor:3.2.0&apos;
compile &apos;io.reactivex:rxandroid:1.1.0&apos;
compile &apos;io.reactivex:rxjava:1.1.0&apos;
compile &apos;com.android.support:recyclerview-v7:23.4.0&apos;
</code></pre><p>两个retrofit依赖包，两个okhttp依赖包，okhttp3:logging-interceptor依赖包主要是拦截请求日志使用，引入下面 要使用的rxandroid的两个依赖包reactivex:rxandroid和reactivex:rxjava，recyclerview主要是新 闻列表页要使用的。</p>
<h2 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h2><p>页面写好了。下面我们通过单例形式创建一个Retrofit对象。</p>
<pre><code>public class HRetrofitNetHelper{
    public static HRetrofitNetHelper mInstance;
    public Retrofit mRetrofit;
    //本地ip为192.168.1.103
    public static final String BASE_URL = &quot;http://192.168.1.103:8080/GoachWeb/&quot;;
    private HRetrofitNetHelper(){
        mRetrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .build();
    }
    public static HRetrofitNetHelper getInstance(){
        if(mInstance==null){
            synchronized (HRetrofitNetHelper.class){
                if(mInstance==null)
                    mInstance = new HRetrofitNetHelper ();
            }
        }
        return mInstance ;
    }
}
</code></pre><p>简单的创建好了一个Retrofit。这里只是配置了一个接口的baseUrl，也就是根路径。</p>
<h2 id="配置ConverterFactory"><a href="#配置ConverterFactory" class="headerlink" title="配置ConverterFactory"></a>配置ConverterFactory</h2><p>如果要Retrofit直接将json转换为为Dao对象。那么我们就要通过addConverterFactory来配置，如下：</p>
<pre><code>mRetrofit = new Retrofit.Builder()
               .addConverterFactory(GsonConverterFactory.create())
               .build();
</code></pre><p>上面是使用依赖：<code>compile&#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;</code>包。然后<code>addConverterFactory</code>来配置。通过源码方法<code>addConverterFactory(Converter.Factory factory)</code>我们可以看到要传入一个继承Converter.Factory的对象。Retrofit里面就有这样的对象，这里我们用的是Gson来进行解析，那就有对应的GsonConverterFactory。那好下面就来创建这个对象</p>
<p>创建这个对象有两种方式</p>
<ul>
<li>一种是像上面写的一样</li>
</ul>
<p>GsonConverterFactory.create()<br>这种方式就是简单的创建默认的Gson对象，然后像我们平常一样转换为Dao对象。</p>
<ul>
<li>还有一种方式就是通过GsonBuilder创建Gson对象</li>
</ul>
<p>比如这里统一把后台提供的带有yyyy-MM-dd HH:mm:ss格式的Date对象，客户端如果用上面这种方式创建的话，会报下面这个错</p>
<pre><code>java.text.ParseException: Failed to parse date [&quot;2016-06-11 20:57:28&apos;]: Invalid time zone indicator &apos; &apos; (at offset 0)
</code></pre><p>这种情况下，我们就可以这样：</p>
<pre><code>Gson mGson = new GsonBuilder()
                .setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create();
然后再创建GsonConverterFactory对象的时候传入Gson
.addConverterFactory(GsonConverterFactory.create(mGson))
</code></pre><p>就可以很好的解决这个问题了。</p>
<p>这里只是说了使用Gson进行解析，其实Retrofit还提供了其他的一些解析工具，如下：</p>
<pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre><p>用法类似这样：<br>导入包(xx可以指Jackson或者Moshi等等)：<code>compile &#39;com.squareup.retrofit2:converter-xx:2.0.2&#39;</code>然后：<code>.addConverterFactory(xxConverterFactory.create(mGson))</code></p>
<p>当然，我们还是可以设置多个<code>converter</code>比如支持 proto 格式和json格式。那么如下添加：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      //...
    .addConverterFactory(ProtoConverterFactory.create())
    .addConverterFactory(GsonConverterFactory.create())
    .build();
</code></pre><p><code>ProtoConverterFactory</code>和<code>GsonConverterFactory</code>添加 <code>converter</code> 的顺序很重要。Retrofit会依次询问每一个 converter 能否处理一个类型。当Retrofit试图反序列化一个 proto 格式，它其实会被当做 JSON 来对待。所以Retrofit会先要检查 proto buffer 格式，然后才是 JSON。所以要先添加ProtoConverterFactory，然后是GsonConverterFactory。<br>又比如我们需要Retrofit支持RxJava。添加：</p>
<pre><code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre><p>就好了。</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ButterKnife的使用]]></title>
      <url>/2017/06/07/ButterKnife%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h2><pre><code>-- 项目地址：https://github.com/Jak eWharton/butterknife
</code></pre><p>都说程序员都是比较懒的，什么事情都想着让程序自动化帮忙减轻工作量，这个开源库可以让我们从大量的<code>findViewById()和setonclicktListener()</code>解放出来，其对性能的影响微乎其微（查看过Butter Knife的源码，其自定义注解的实现都是限定为RetentionPolicy.CLASS，也就是到编译出.class文件为止有效，在运行时不额外消耗性能，其是通过java注解自动生成java代码的形式来完成工作），其也有一个明显的缺点，那就是代码的可读性差一些，但了解了之后，上手也很快。。。</p>
<h2 id="解放控件对象实例化"><a href="#解放控件对象实例化" class="headerlink" title="解放控件对象实例化"></a>解放控件对象实例化</h2><p>也就是 findViewById()，一直以来的做法都是一个个定义，然后在 setContentView() 或 inflate() 之后一一来findViewById()进行实例化，而使用 ButterKnife，你只需要在代码中 使用注解方式进行对象申明，然后在 setContentView() 或 inflate() 之后调用一句话，那么申明的所有对象自动创建出来。</p>
<pre><code> 1     @InjectView(R.id.ok_btn) //控件对应的ID
 2     Button mBtn;
 3 
 4     @InjectView(R.id.title_text)
 5     TextView mTitleTextView;
 6 
 7     @Override
 8     protected void onCreate(Bundle savedInstanceState) {
 9         super.onCreate(savedInstanceState);
10         setContentView(R.layout.main_activity);
11 
12         ButterKnife.inject(this);
13 
14         //这样之后就可以直接使用变量了
15         mTitleTextView.setText(&quot;test&quot;);
16 
17     }
</code></pre><p>是不是很神奇！！！<br>Fragment的和adapter里也可以用，不过调用时要多加一个root view参数。<br>Fragegment使用时记得同时继承onDestroyView，并在其中将ButterKnife.reset</p>
<pre><code> 1 public class FancyFragment extends Fragment {
 2   @InjectView(R.id.button1) Button button1;
 3   @InjectView(R.id.button2) Button button2;
 4 
 5   @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 6     View view = inflater.inflate(R.layout.fancy_fragment, container, false);
 7     ButterKnife.inject(this, view);
 8     // TODO Use &quot;injected&quot; views...
 9     return view;
10   }
11 }
12 
13   @Override void onDestroyView() {
14     super.onDestroyView();
15     ButterKnife.reset(this);
16   }
</code></pre><p>还可以实例化控件数组，注解多一个s，也就是 InjectViews</p>
<pre><code>1 @InjectViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews;
</code></pre><p>解放监听添加<br>如下，可以直接为 R.id.submit这个控件添加OnClickListener为submit函数，流弊啊。。。</p>
<pre><code>1 @OnClick(R.id.submit)
2 public void submit() {
3   // TODO submit data to server...
4 }
还可以批量为多个控件添加为同一个响应函数：

1 @OnClick({ R.id.door1, R.id.door2, R.id.door3 })
2   public void pickDoor(DoorView door) {
3    if (door.hasPrizeBehind()) {
4         Toast.makeText(this, &quot;You win!&quot;, LENGTH_SHORT).show();
5    } else {
6        Toast.makeText(this, &quot;Try again&quot;, LENGTH_SHORT).show();
7    }
8   }
</code></pre><p>具体的可以去看该大神的项目页面。在文前已给出。<br>注：最新版的库已经将方法名改了，当然也是兼容上面所列的例子的。最新示例如下：</p>
<pre><code>1 class ExampleActivity extends Activity {
 2   @FindView(R.id.user) EditText username;
 3   @FindView(R.id.pass) EditText password;
 4 
 5   @OnClick(R.id.submit) void submit() {
 6     // TODO call server...
 7   }
 8 
 9   @Override public void onCreate(Bundle savedInstanceState) {
10     super.onCreate(savedInstanceState);
11     setContentView(R.layout.simple_activity);
12     ButterKnife.bind(this);
13     // TODO Use fields...
14   }
15 }
</code></pre>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[handler和AsyncTask学习笔记]]></title>
      <url>/2017/06/07/handler%E5%92%8CAsyncTask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="AsyncTask实现的原理和适用的优缺点"><a href="#AsyncTask实现的原理和适用的优缺点" class="headerlink" title="AsyncTask实现的原理和适用的优缺点"></a>AsyncTask实现的原理和适用的优缺点</h2><p>AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.</p>
<ol>
<li><p>使用的优点:</p>
<p>简单，快捷，过程可控 </p>
</li>
</ol>
<ol>
<li><p>使用的缺点:</p>
<p>在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.</p>
</li>
</ol>
<h2 id="Handler异步实现的原理和适用的优缺点"><a href="#Handler异步实现的原理和适用的优缺点" class="headerlink" title="Handler异步实现的原理和适用的优缺点"></a>Handler异步实现的原理和适用的优缺点</h2><p>在Handler 异步实现时,涉及到 <code>Handler, Looper, Message,Thread</code>四个对象，实现异步的流程是主线程启动Thread（子线程）运行并生成Message-Looper获取Message并传递给HandlerHandler逐个获取Looper中的Message，并进行UI变更。</p>
<ol>
<li><p>使用的优点：</p>
<p>结构清晰，功能定义明确<br>对于多个后台任务时，简单，清晰</p>
</li>
<li><p>使用的缺点：</p>
<p> 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）</p>
</li>
</ol>
<h2 id="AsyncTask介绍"><a href="#AsyncTask介绍" class="headerlink" title="AsyncTask介绍"></a>AsyncTask介绍</h2><p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。<br>首先明确Android之所以有Handler和AsyncTask，都是为了不阻塞主线程（UI线程），且UI的更新只能在主线程中完成，因此异步处理是不可避免的。</p>
<p>Android为了降低这个开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，顾名思义就是异步任务。<br>AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法(至少重载一个)。</p>
<p>AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>
<pre><code>  ● Params 启动任务执行的输入参数，比如HTTP请求的URL。
  ● Progress 后台任务执行的百分比。
  ● Result 后台执行任务最终返回的结果，比如String。
使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：
  ● doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。
  ● onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回
有必要的话你还得重写以下这三个方法，但不是必须的：
  ● onProgressUpdate(Progress…)   可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。
  ● onPreExecute()        这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。
  ● onCancelled()             用户调用取消时，要做的操作
使用AsyncTask类，以下是几条必须遵守的准则：
  ● Task的实例必须在UI thread中创建；
  ● execute方法必须在UI thread中调用；
  ● 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几个方法；
  ● 该task只能被执行一次，否则多次调用时将会出现异常；
</code></pre><h2 id="Handler介绍"><a href="#Handler介绍" class="headerlink" title="Handler介绍"></a>Handler介绍</h2><ol>
<li><p>Handler主要接受子线程发送的数据, 并用此数据配合主线程更新UI.</p>
<p>当应用程序启动时，Android首先会开启一个主线程,主线程为管理界面中的UI控件，进行事件分发,更新UI只能在主线程中更新，子线程中操作是危险的。这个时候，Handler就需要出来解决这个复杂的问题。由于Handler运行在主线程中(UI线程中),它与子线程可以通过Message对象来传递数据, 这个时候，Handler就承担着接受子线程传过来的(子线程用sedMessage()方法传递)Message对象(里面包含数据), 把这些消息放入主线程队列中，配合主线程进行更新UI。</p>
</li>
<li><p>Handler的特点</p>
<p>Handler可以分发Message对象和Runnable对象到主线程中,每个Handler实例,都会绑定到创建他的线程中,它有两个作用:</p>
<p> (1)安排消息或Runnable 在某个主线程中某个地方执行<br> (2)安排一个动作在不同的线程中执行</p>
</li>
<li><p>Handler中分发消息的一些方法</p>
<p>post(Runnable)<br>postAtTime(Runnable,long)<br>postDelayed(Runnable long)<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
</li>
</ol>
<p>以上post类方法允许你排列一个Runnable对象到主线程队列中,sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新。</p>
<p>综上所述：数据简单使用AsyncTask:实现代码简单，数据量多且复杂使用handler+thread:相比较AsyncTask来说能更好的利用系统资源且高效</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> android基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Blog中添加音乐]]></title>
      <url>/2017/06/06/%E5%9C%A8Blog%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/</url>
      <content type="html"><![CDATA[<p>在Blog中添加音乐播放器有两种，一种是歌单另一种是在一篇文章中插入歌曲，以网易云为例介绍一下这两种方法</p>
<h2 id="歌单或者单曲播放器"><a href="#歌单或者单曲播放器" class="headerlink" title="歌单或者单曲播放器"></a>歌单或者单曲播放器</h2><p>这种播放器依靠网易云音乐生成的外链播放器</p>
<p><img src="/images/20170606211501.jpg" alt="此处输入图片的描述"></p>
<p><img src="/images/20170606212001.jpg" alt="此处输入图片的描述"></p>
<p><img src="/images/20170606211330.jpg" alt="此处输入图片的描述"></p>
<p>代码如下：</p>
<pre><code>&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=427685783&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;
</code></pre><p>效果如下，可以在Blog相应的位置中添加代码段即可显示播放器效果，修改歌单只需要在网易云音乐中将相应的歌单修改即可。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=427685783&auto=0&height=430"></iframe>

<p>嘿嘿其实这里有一个坑就是你拿到我上面的示例代码后直接粘贴会发现音乐是自动播放的，其实在代码中将<code>auto=1</code>属性改为<code>auto=0</code>即可。<br>或者，直接在生成外链播放器时把自动播放取消。</p>
<p>相应的，单首歌也可以用这种方法生成播放器，插入到文章中。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5054922&auto=0&height=66"></iframe>

<p>文章最后送大家一首Notting Hill中的Ain’t no sunshine。</p>
<p>ps:由于版权原因可能有的歌单和单曲不能生成播放。</p>
]]></content>
      
        <categories>
            
            <category> 技术闲谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_Collection]]></title>
      <url>/2017/06/06/Java-Collection/</url>
      <content type="html"><![CDATA[<h2 id="Collection层次结构"><a href="#Collection层次结构" class="headerlink" title="Collection层次结构"></a>Collection层次结构</h2><p><img src="http://img.blog.csdn.net/20130821151227718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRsd2M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Collection层次结构"></p>
<p><img src="http://my.csdn.net/uploads/201206/02/1338603398_8372.jpg" alt="Collection层次结构"></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><pre><code>子接口  
    Set,List  
集合中只能放置对象的引用,不能放置原生数据类型,  
    我们需要使用原生数据类型的封装类才能加入到集合中  
</code></pre><h2 id="Ordered与Sorted接口"><a href="#Ordered与Sorted接口" class="headerlink" title="Ordered与Sorted接口"></a>Ordered与Sorted接口</h2><pre><code>Ordered排序,按照某种由具体情况决定的顺序排序,是后天指定的  
Sorted排序,按照天然顺序进行排序,是先天指定的  
</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre><code>实现类包括  
    LinkedList,Vector,ArrayList  
列表接口,继承与Collection,可以按索引的顺序访问,有索引的Collection  
    具有列表的功能,元素顺序均是按添加的先后进行排列的,  
    允许重复的元素,允许多个null元素  
</code></pre><h2 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        List list = new ArrayList();  
        // 向列表的尾部追加指定的元素  
        list.add(&quot;lwc&quot;);  
        // 在列表的指定位置插入指定元素  
        list.add(1, &quot;nxj&quot;);  
        // 追加指定 collection 中的所有元素到此列表的结尾  
        list.addAll(new ArrayList());  
        // 从列表中移除所有元素  
        list.clear();  
        // 如果列表包含指定的元素,则返回true  
        list.contains(&quot;nxj&quot;);  
        // 如果列表包含指定 collection 的所有元素,则返回 true  
        list.containsAll(new ArrayList());  
        // 比较指定的对象与列表是否相等  
        list.equals(new ArrayList());  
        // 返回列表中指定位置的元素  
        list.get(0);  
        // 返回列表的哈希码值  
        list.hashCode();  
        // 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1  
        list.indexOf(&quot;lwc&quot;);  
        // 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1  
        list.lastIndexOf(&quot;lwc&quot;);  
        // 如果列表不包含元素,则返回 true  
        list.isEmpty();  
        // 移除列表中指定位置的元素  
        list.remove(0);  
        // 移除列表中出现的首个指定元素  
        list.remove(&quot;lwc&quot;);  
        // 从列表中移除指定 collection 中包含的所有元素  
        list.removeAll(new ArrayList());  
        // 用指定元素替换列表中指定位置的元素  
        list.set(0, &quot;lp&quot;);  
        // 返回列表中的元素数  
        list.size();  
        // 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图  
        list.subList(1, 2);  
        // 返回以正确顺序包含列表中的所有元素的数组  
        list.toArray();  
        // 返回以正确顺序包含列表中所有元素的数组  
        list.toArray(new String[] { &quot;a&quot;, &quot;b&quot; });  
    }  
}  
</code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><pre><code>构造方法  
    public ArrayList()  
    public ArrayList(int initialCapacity)  
    public ArrayList(Collection c)  
ArrayList依赖于数组实现的,初始长度为10的Object[],并且可随需要而增加的动态数组  
    当元素超过10,那么ArrayList底层会新生成一个数组,长度为原来的1.5倍+1,  
    然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,  
    当新数组无法容纳增加的元素,重复该过程  
ArrayList对随机访问性能很好,但进行大量插入,删除操作,性能很差,  
    因为操作之后后续元素需要移动  
</code></pre><h2 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.Iterator;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();  
        list.add(&quot;lwc&quot;);  
        list.add(&quot;nxj&quot;);  
        // 方法一  
        Iterator&lt;String&gt; ite1 = list.iterator();  
        while (ite1.hasNext()) {  
            String str = ite1.next();  
            System.out.println(str);  
        }  
        System.out.println(&quot;---------------------&quot;);  
        // 方法二(方法一的变形)  
        for (Iterator&lt;String&gt; ite2 = list.iterator(); ite2.hasNext();) {  
            String str = ite2.next();  
            System.out.println(str);  
        }  
        System.out.println(&quot;---------------------&quot;);  
        // 方法三  
        for(String s : list){  
            System.out.println(s);  
        }  
    }  
}  
/* 
打印结果: 
    lwc 
    nxj 
    --------------------- 
    lwc 
    nxj 
    --------------------- 
    lwc 
    nxj 
*/  
</code></pre><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><pre><code>向量,历史比较悠久,Java诞生就有了,特点与ArrayList相同,  
    不同的是Vector操作元素的方法是同步的,同一时刻只能有一个线程访问,没有特殊需求都使用ArrayList  
构造方法  
    public Vector()  
    public Vector(int initialCapacity)  
    public Vector(int initialCapacity,int capacityIncrement)  
        第一个参数是初始容量,第二个参数是当Vector满时的增量  
    public Vector(Collection c)  
Vector也是依赖数组实现的 
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;  

import java.util.Enumeration;  
import java.util.Vector;  

public class Test {  
    public static void main(String[] args) {  
        Vector v = new Vector();  
        v.add(&quot;123&quot;);  
        v.add(&quot;lwc&quot;);  
        v.add(&quot;你好&quot;);  
        // Vector转换为枚举  
        Enumeration e = v.elements();  
        while (e.hasMoreElements()) {  
            System.out.println(e.nextElement());  
        }  
    }  
}
</code></pre><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><pre><code>Vector的子类
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;

import java.util.Enumeration;  
import java.util.Stack;  

public class Test {  
    public static void main(String[] args) {  
        Stack stack = new Stack();  
        // 向栈里面压一个整数  
        stack.push(new Integer(123));  
        stack.push(&quot;lwc&quot;);  
        stack.push(new Double(88.88));  
        // 遍历  
        Enumeration items = stack.elements();  
        while (items.hasMoreElements()) {  
            System.out.print(items.nextElement() + &quot; &quot;);  
        }  
        System.out.println();  
        // 出栈  
        while (stack.size() != 0) {  
            System.out.print(stack.pop() + &quot; &quot;);  
        }  
    }  
}  
/* 
打印结果: 
    123 lwc 88.88  
    88.88 lwc 123 
*/  
</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><pre><code>LinkedList功能与ArrayList,Vector相同,内部是依赖双链表实现的,  
    因此有很好的插入和删除性能,但随机访问元素的性能很差  
构造方法  
    public LinkedList()  
    public LinkedList(Collection c)  
LinkedList类中有一个Entry内部类,Entry内部类包含3个部分向前的引用,向后的引用,数据  
    header.next = header.previous = header;  
</code></pre><h2 id="遍历LinkedList"><a href="#遍历LinkedList" class="headerlink" title="遍历LinkedList"></a>遍历LinkedList</h2><pre><code>package com.itlwc;  

import java.util.LinkedList;  
import java.util.List;  
import java.util.ListIterator;  

public class Test {  
    public static void main(String[] args) {  
        List link = new LinkedList();  
        link.add(123);  
        link.add(&quot;lwc&quot;);  
        link.add(8.8);  
        link.add(&quot;nxj&quot;);  
        link.add(520);  
        printList(link);  
        printReversedList(link);  
    }  


private static void printList(List link) {  
    System.out.println(&quot;正序链表中的元素&quot;);  
    // 的到链表的迭代器,位置指向链头  
    ListIterator li = link.listIterator();  
    // 判断迭代器中是否有下一个元素  
    while (li.hasNext()) {  
        // 返回下个元素  
        System.out.print(li.next() + &quot; &quot;);  
    }  
    System.out.println();  
}  

private static void printReversedList(List link) {  
    System.out.println(&quot;逆向链表中的元素&quot;);  
    // 的到链表的迭代器,位置指向link.size()结尾  
    ListIterator li = link.listIterator(link.size());  
    // 判断迭代器中是否有前一个元素  
    while (li.hasPrevious()) {  
        // 返回前一个元素  
        System.out.print(li.previous() + &quot; &quot;);  
    }  
    System.out.println();  
}  
}  
/* 
打印结果: 
    正序链表中的元素 
    123 lwc 8.8 nxj 520  
    逆向链表中的元素 
    520 nxj 8.8 lwc 123  
*/
</code></pre><h2 id="自定义LinkedList结构"><a href="#自定义LinkedList结构" class="headerlink" title="自定义LinkedList结构"></a>自定义LinkedList结构</h2><pre><code>package com.itlwc;  

class Node {  
    Node previous;// 前驱  
    String data;// 数据  
    Node next;// 后驱  

    public Node(String data) {  
        this.data = data;  
    }  
}  

public class Test {  
    public static void main(String[] args) {  
        Node node1 = new Node(&quot;node1&quot;);  
        Node node2 = new Node(&quot;node2&quot;);  
        Node node3 = new Node(&quot;node3&quot;);  
        node1.next = node2;  
        node2.previous = node1;  
        node2.next = node3;  
        node3.previous = node2;  
        node3.next = node1;  
        node1.previous = node3;  

        // 增加node4  
        Node node4 = new Node(&quot;node4&quot;);  
        node1.next = node4;  
        node4.previous = node1;  
        node4.next = node2;  
        node2.previous = node4;  
        // 删除node4  
        node1.next = node2;  
        node2.previous = node1;  
        node4.previous = null;  
        node4.next = null;  

    }  
}  
</code></pre><h2 id="依赖倒置原理"><a href="#依赖倒置原理" class="headerlink" title="依赖倒置原理"></a>依赖倒置原理</h2><pre><code>依赖应该尽量在抽象层进行,避免在具体层进行,  
    在实际开发中尽量使用接口类型的引用,避免采用具体类型的引用  
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;  

import java.util.LinkedList;  
import java.util.List;  

public class Test {  
    //如果我们需要传入参数是ArrayList就需要改动代码  
    public void printLinkedList(LinkedList ll){  
        System.out.println(ll);  
    }  
    //如果我们传入参数是List的子类,我们不需要改动代码,灵活性大  
    public void printList(List l){  
        System.out.println(l);  
    }  
}
</code></pre><h2 id="将数组转换为列表"><a href="#将数组转换为列表" class="headerlink" title="将数组转换为列表"></a>将数组转换为列表</h2><pre><code>package com.itlwc;  

import java.util.Arrays;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        String[] str = { &quot;l&quot;, &quot;w&quot;, &quot;c&quot; };  
        //使用Java类库中java.util.Arrays类的静态方法asList()  
        List l = Arrays.asList(str);  
        System.out.println(str);  
    }  

}  
/* 
打印结果: 
    [l, w, c] 
*/  
</code></pre><h2 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h2><pre><code>ArrayList底层采用数组实现,LinkedList底层采用双链表实现  
如果为列表增加对象  
    ArrayList是ArrayList底层数组维护的,LinkedList是LinkedList底层Entry对象维护的  
    LinkedList底层Entry结构  
        Entry{  
            Entry previous;  
            Object element;  
            Entry next;  
        }  
        其中element就是我们添加的元素,最后将生成的Entry对象加入到链表中  
插入和删除操作时,采用LinkedList好,搜索时,采用ArrayList好  
</code></pre><h2 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List<map>遍历</map></h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.Iterator;  
import java.util.List;  
import java.util.Map;  

public class Test {  
    public static void main(String[] args) {  
        Map&lt;Integer, String&gt; map1 = new HashMap&lt;Integer, String&gt;();  
        map1.put(new Integer(1), &quot;lwc&quot;);  
        map1.put(new Integer(2), &quot;nxj&quot;);  
        Map&lt;Integer, String&gt; map2 = new HashMap&lt;Integer, String&gt;();  
        map2.put(new Integer(3), &quot;tom&quot;);  
        map2.put(new Integer(4), &quot;cat&quot;);  
        List&lt;Map&lt;Integer, String&gt;&gt; list = new ArrayList&lt;Map&lt;Integer, String&gt;&gt;();  
        list.add(map1);  
        list.add(map2);  
        // 方法一  
        Iterator&lt;Map&lt;Integer, String&gt;&gt; ite1 = list.iterator();  
        while (ite1.hasNext()) {  
            Map&lt;Integer, String&gt; m = ite1.next();  
            System.out.println(m);  
        }  
        System.out.println(&quot;-----------------------------&quot;);  
        // 方法二(方法一的变形)  
        for (Iterator&lt;Map&lt;Integer, String&gt;&gt; ite2 = list.iterator(); ite2.hasNext();) {  
            Map&lt;Integer, String&gt; m = ite2.next();  
            System.out.println(m);  
        }  
        System.out.println(&quot;-----------------------------&quot;);  
        // 方法三:  
        for (Map&lt;Integer, String&gt; m : list) {  
            System.out.println(m);  
        }  
    }  
}  
/*  
打印结果:  
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
    ----------------------------- 
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
    ----------------------------- 
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
*/  
</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>实现类  
    HashSet,LinkedHashSet  
子接口  
    SortSet  
    实现类  
        TreeSet  
不包含重复元素,最多包含一个null,元素没有顺序  
</code></pre><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><pre><code>HashSet不是Ordered也不是Sorted,存储对象引用时是按照哈希策略来实现的,  
    HashSet中是否存在一个对象是通过equals()和hashCode()协同判断  
不保证顺序  
构造方法  
    public HashSet()    
    public HashSet(int initialCapacity)    
    public HashSet(Collection c)  
HashSet底层是使用HashMap实现的  
HashSet的add()方法详解:  
    判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致  
    如果不一致,直接加进去  
    如果一致,再进行equals()比较  
        如果equals()返回true,对象已经存在不增加进去  
        如果equals()返回false,把对象增加进去  
</code></pre><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><pre><code>LinkedHashSet是Ordered,采用双链表实现的  
有固定顺序,也就是插入顺序  
LinkedHashSet底层是使用LinkedHashMap实现的  
构造方法  
    public LinkedHashSet()    
    public LinkedHashSet(int initialCapacity)    
    public LinkedHashSet(Collection c)  
</code></pre><h2 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h2><pre><code>保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序  
常用方法  
    Object first()  
         返回此有序集合中当前第一个(最小的)元素  
    Object last()  
        返回此有序集合中最后一个(最大的)元素  
    SortedSet headSet(Object toElement)  
        返回此有序集合的部分视图,其元素严格小于toElement  
    SortedSet tailSet(Object fromElement)  
        返回此有序集合的部分视图,其元素大于或等于fromElement  
    SortedSet subSet(Object fromElement,Object toElement)  
        返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括)  
    Comparator comparator()  
        返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null  
</code></pre><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><pre><code>TreeSet是SortedSet接口的实现,元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历  
TreeSet底层是使用TreeMap实现的  
构造方法  
    public TreeSet()  
    public TreeSet(SortedSet s)    
    public TreeSet(int initialCapacity)  
    public TreeSet(Comparator&lt;? super E&gt;)  
    public TreeSet(Collection c)  
因为TreeSet是带排序的,所以想要为TreeSet增加自定义类型,必须指定排序规则
</code></pre><h2 id="TreeSet排序规则Comparator案例"><a href="#TreeSet排序规则Comparator案例" class="headerlink" title="TreeSet排序规则Comparator案例"></a>TreeSet排序规则Comparator案例</h2><pre><code>package com.itlwc;  

import java.util.Comparator;  
import java.util.Iterator;  
import java.util.TreeSet;  

public class Test {  
    public static void main(String[] args) {  
        TreeSet set = new TreeSet(new PersonComparator());  
        set.add(new Person(&quot;lwc&quot;, 80));  
        set.add(new Person(&quot;nxj&quot;, 70));  
        set.add(new Person(&quot;lp&quot;, 60));  
        set.add(new Person(&quot;fy&quot;, 75));  
        Iterator ite = set.iterator();  
        while (ite.hasNext()) {  
            Person p = (Person)ite.next();  
            System.out.println(p.name);  
        }  
    }  
}  

class Person {  
    String name;  
    int score;  

    public Person(String name, int score) {  
        this.name = name;  
        this.score = score;  
    }  
}  

class PersonComparator implements Comparator {  
    public int compare(Object o1, Object o2) {  
        Person p1 = (Person) o1;  
        Person p2 = (Person) o2;  
        return p1.score - p2.score;  
    }  
}  
</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>操作Collection类的工具类,类中方法都是静态的</p>
<h2 id="Collections常用方法"><a href="#Collections常用方法" class="headerlink" title="Collections常用方法"></a>Collections常用方法</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.Collections;  
import java.util.Comparator;  

public class Test {  
    public static void main(String[] args) {  
        // 将所有元素从一个列表复制到另一个列表  
        Collections.copy(new ArrayList(), new ArrayList());  
        // 如果两个指定collection中没有相同的元素,则返回 true  
        Collections.disjoint(new ArrayList(), new ArrayList());  
        // 使用指定元素替换指定列表中的所有元素  
        Collections.fill(new ArrayList(), new Object());  
        // 返回指定 collection 中等于指定对象的元素数  
        Collections.frequency(new ArrayList(), new Object());  
        // 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1  
        Collections.indexOfSubList(new ArrayList(), new ArrayList());  
        // 根据元素的自然顺序，返回给定 collection 的最大元素  
        Collections.max(new ArrayList());  
        // //根据元素的自然顺序，返回给定 collection 的最大元素  
        Collections.min(new ArrayList());  
        // 使用另一个值替换列表中出现的所有某一指定值  
        Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);  
        // 反转指定列表中元素的顺序  
        Collections.reverse(new ArrayList());  
        // 返回一个比较器,它强行反转  
        Collections.reverseOrder();  
        // 返回一个比较器,它强行反转指定比较器的顺序  
        Collections.reverseOrder(new Comparator() {  
            @Override  
            public int compare(Object o1, Object o2) {  
                return 0;  
            }  
        });  
        // 使用默认随机源随机更改指定列表的序列  
        Collections.shuffle(new ArrayList());  
        // 根据元素的自然顺序对指定列表按升序进行排序  
        Collections.sort(new ArrayList());  
        // 根据元素的自然顺序对指定列表按降序进行排序  
        Collections.sort(new ArrayList(), Collections.reverseOrder());  
        // 在指定列表的指定位置处交换元素  
        Collections.swap(new ArrayList(), 1, 2);  

    }  
}  
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_多态的性质]]></title>
      <url>/2017/06/06/Java-%E5%A4%9A%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      <content type="html"><![CDATA[<p>面向对象编程有三大特性：封装、继承、多态。</p>
<p>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</p>
<p>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：</p>
<pre><code>酒 a = 剑南春

酒 b = 五粮液

酒 c = 酒鬼酒

…
</code></pre><p>这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p>
<p>诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：</p>
<pre><code>JNC a = new  JNC();
</code></pre><p>对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？</p>
<pre><code>Wine a = new JNC();
</code></pre><p>在这里我们这样理解，这里定义了一个Wine类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了。</p>
<pre><code>public class Wine {
    public void fun1(){
        System.out.println(&quot;Wine 的Fun.....&quot;);
        fun2();
    }

    public void fun2(){
        System.out.println(&quot;Wine 的Fun2...&quot;);
    }
}

public class JNC extends Wine{
    /**
     * @desc 子类重载父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的
     * @param a
     * @return void
     */
    public void fun1(String a){
        System.out.println(&quot;JNC 的 Fun1...&quot;);
        fun2();
    }

    /**
     * 子类重写父类方法
     * 指向子类的父类引用调用fun2时，必定是调用该方法
     */
    public void fun2(){
        System.out.println(&quot;JNC 的Fun2...&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        Wine a = new JNC();
        a.fun1();
    }
}
-------------------------------------------------
Output:
Wine 的Fun.....
JNC 的Fun2...
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_final 和 static]]></title>
      <url>/2017/06/06/Java-final-%E5%92%8C-static/</url>
      <content type="html"><![CDATA[<p>Java关键字final、static使用总结</p>
<h2 id="一、final"><a href="#一、final" class="headerlink" title="一、final"></a>一、final</h2><p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。<br>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<ul>
<li><p>1、final类</p>
<p> final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>
</li>
<li><p>2、final方法</p>
</li>
</ul>
<p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>使用final方法的原因有二：<br>第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>例如：</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
    // TODO 自动生成方法存根
    }
    public void f1() {
        System.out.println(&quot;f1&quot;);
    }
    //无法被子类覆盖的方法
    public final void f2() {
        System.out.println(&quot;f2&quot;);
    }
    public void f3() {
        System.out.println(&quot;f3&quot;);
    }
    private void f4() {
        System.out.println(&quot;f4&quot;);
    }
    }
    public class Test2 extends Test1 {

    public void f1(){    
        System.out.println(&quot;Test1父类方法f1被覆盖!&quot;);
    }
    public static void main(String[] args) {
        Test2 t=new Test2();
        t.f1();    
        t.f2(); //调用从父类继承过来的final方法
        t.f3(); //调用从父类继承过来的方法
        //t.f4(); //调用失败，无法从父类继承获得
    }
}
</code></pre><ul>
<li>3、final变量（常量）<br>用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</li>
</ul>
<pre><code>package org.leizhimin;

public class Test3 {
        private final String S = &quot;final实例变量S&quot;;
        private final int A = 100;
        public final int B = 90;



 public static final int C = 80;
    private static final int D = 70;
        public final int E; //final空白,必须在初始化对象的时候赋初值



  public Test3(int x) {
            E = x;
    }

/**
 * @param args
 */
public static void main(String[] args) {
        Test3 t = new Test3(2);
        //t.A=101;    //出错,final变量的值一旦给定就无法改变
        //t.B=91; //出错,final变量的值一旦给定就无法改变
        //t.C=81; //出错,final变量的值一旦给定就无法改变
        //t.D=71; //出错,final变量的值一旦给定就无法改变

                System.out.println(t.A);
                System.out.println(t.B);
                System.out.println(t.C); //不推荐用对象方式访问静态字段
                System.out.println(t.D); //不推荐用对象方式访问静态字段
                System.out.println(Test3.C);
                System.out.println(Test3.D);
                //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同.
                System.out.println(t.E);

            Test3 t1 = new Test3(3);
            System.out.println(t1.E); //final空白变量E依据对象的不同而不同
    }

        private void test() {
                System.out.println(new Test3(1).A);
                System.out.println(Test3.C);
                System.out.println(Test3.D);
        }

        public void test2() {
                final int a;     //final空白,在需要的时候才赋值
                final int b = 4;    //局部常量--final用于局部变量的情形
                final int c;    //final空白,一直没有给赋值.    
                a = 3;
                //a=4;    出错,已经给赋过值了.
                //b=2; 出错,已经给赋过值了.
        }
}
</code></pre><p>4、final参数<br>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>
<pre><code>public class Test4 {
           public static void main(String[] args) {
                   new Test4().f1(2);
           }
           public void f1(final int i) {
                   //i++;    //i是final类型的,值不允许改变的.
                   System.out.print(i);
           }
   }
</code></pre><p>二、static</p>
<pre><code>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。

被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。

static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。

static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：
</code></pre><p>类名.静态方法名(参数列表…)<br>类名.静态变量名<br>        用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。</p>
<p>1、static变量<br>        按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>        对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>        对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>
<p>2、静态方法<br>        静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>3、static代码块<br>        static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<p>public class Test5 {<br>        private static int a;<br>        private int b;</p>
<pre><code>static {
        Test5.a = 3;
        System.out.println(a);
        Test5 t = new Test5();
        t.f();
        t.b = 1000;
        System.out.println(t.b);
}

static {
        Test5.a = 4;
        System.out.println(a);
}

public static void main(String[] args) {
        // TODO 自动生成方法存根
}

static {
        Test5.a = 5;
        System.out.println(a);
}

public void f() {
        System.out.println(&quot;hhahhahah&quot;);
}
</code></pre><p>}</p>
<p>运行结果：<br>3<br>hhahhahah<br>1000<br>4<br>5<br>        利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>
<p>4、static和final一块用表示什么<br>        static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>        对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>        对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<pre><code>特别要注意一个问题：
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。
也许说了这么多，反倒把你搞晕了，还是看个例子吧：
</code></pre><p>public class TestStaticFinal {<br>        private static final String strStaticFinalVar = “aaa”;<br>        private static String strStaticVar = null;<br>        private final String strFinalVar = null;<br>        private static final int intStaticFinalVar = 0;<br>        private static final Integer integerStaticFinalVar = new Integer(8);<br>        private static final ArrayList<string> alStaticFinalVar = new ArrayList<string>();</string></string></p>
<pre><code>private void test() {
        System.out.println(&quot;-------------值处理前----------\r\n&quot;);
        System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;);
        System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;);


        //strStaticFinalVar=&quot;哈哈哈哈&quot;;        //错误，final表示终态,不可以改变变量本身.
        strStaticVar = &quot;哈哈哈哈&quot;;                //正确，static表示类变量,值可以改变.
        //strFinalVar=&quot;呵呵呵呵&quot;;                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        alStaticFinalVar.add(&quot;aaa&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。
        alStaticFinalVar.add(&quot;bbb&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。

        System.out.println(&quot;-------------值处理后----------\r\n&quot;);
        System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;);
        System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;);
}

public static void main(String args[]) {
        new TestStaticFinal().test();
}
</code></pre><p>}</p>
<p>运行结果如下：<br>————-值处理前———-<br>strStaticFinalVar=aaa<br>strStaticVar=null<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[]<br>————-值处理后———-<br>strStaticFinalVar=aaa<br>strStaticVar=哈哈哈哈<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[aaa, bbb]</p>
<p>Process finished with exit code 0</p>
<pre><code>看了上面这个例子，就清楚很多了，但必须明白：通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方。
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建造者模式（Builder Pattern）]]></title>
      <url>/2017/06/06/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>建造者模式（Builder Pattern） 也叫生成器模式其定义如下：<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>四个要素：</p>
<pre><code>产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。

抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。

建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。

导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。
</code></pre><p>#一 Builder模式介绍及使用场景<br>Builder模式是一步一步创建一个复杂对象的创建者模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p>
<p>因为一个复杂的对象有很多大量组成部分，如汽车，有车轮、方向盘、发动机，还有各种小零件，如何将这件部件装配成一辆汽车，这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，也可以使用Builder模式将部件和组装过程分离，使得构建过程和部件都可以自有拓展，两者之间的耦合也降到最低。</p>
<p>在项目中最常见到的两个使用Builder模式的案例，一个是AlertDialog.Builder的创建，另一个就是著名的图片加载框架ImageLoader的初始配置。</p>
<p>ImageLoader的初始配置如下：</p>
<pre><code>ImageLoaderConfiguration config = new ImageLoaderConfiguration  
    .Builder(context)  
    .memoryCacheExtraOptions(480, 800) // max width, max height，即保存的每个缓存文件的最大长宽  
    .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) // Can slow ImageLoader, use it carefully (Better don&apos;t use it)/设置缓存的详细信息，最好不要设置这个  
    .threadPoolSize(3)//线程池内加载的数量  
    .threadPriority(Thread.NORM_PRIORITY - 2)  
    .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You can pass your own memory cache implementation/你可以通过自己的内存缓存实现  
    .memoryCacheSize(2 * 1024 * 1024)   //设置内存缓存的大小 
    .discCacheSize(50 * 1024 * 1024)    //设置磁盘缓存的大小
    .discCacheFileNameGenerator(new Md5FileNameGenerator())//将保存的时候的URI名称用MD5 加密   
    .discCacheFileCount(100) //缓存的文件数量  
    .discCache(new UnlimitedDiscCache(cacheDir))//自定义缓存路径      
         .defaultDisplayImageOptions(DisplayImageOptions.createSimple())  
    .imageDownloader(new BaseImageDownloader(context, 5 * 1000, 30 * 1000)) // connectTimeout (5 s), readTimeout (30 s)超时时间  
    .writeDebugLogs() // Remove for release app  
    .build();//开始构建
//然后   
 ImageLoader.getInstance().init(config);//全局初始化此配置  
</code></pre><p>Builder模式的使用场景：<br>（1）多个部件或零件，不同的执行顺序，产生不同的事件结果时；<br>（2）多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。<br>（3）当初始化一个对象特别复杂，参数多，且很多参数都具有默认值。</p>
<p>#二 Builder模式的结构图</p>
<p>结构图如下：<br>角色介绍：<br>（1）Product：产品的抽象类<br>（2）Builder：抽象的Builder类，规范产品的组件，一般由子类实现具体的组建过程。<br>（3）ConcreteBuilder: 具体的Builder类。<br>（4）Director：统一的组装过程。</p>
<p><img src="http://img.blog.csdn.net/20160416154928614" alt="此处输入图片的描述"></p>
<p>#三 Builder模式的简单DEMO：</p>
<p><a href="http://blog.csdn.net/hello_haozi/article/details/38819935" target="_blank" rel="external">Builder模式的简单Demo</a></p>
<p>看过了这个例子，可以发现这个例子和我们一开始看到的类似ImageLoade初始配置那样的链式调用是不一样的，因为忽略了Director的角色。</p>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="external">深入理解一下Director的作用</a></p>
<p>#四 分析源码<br>OkHttp</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对RecyclerView Item做动画]]></title>
      <url>/2017/06/06/%E5%AF%B9RecyclerView-Item%E5%81%9A%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p><strong>参考于：<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650820629&amp;idx=1&amp;sn=dafee7298419df6c9161368db7f7198d&amp;scene=4#wechat_redirect" target="_blank" rel="external">由Ru_Zhan投稿的微信文章</a></strong><br>添加动态位移，静态位移，缩放等动画，保证动画状态的平滑衔接。</p>
<p>RecyclerView，ListView这些具有Item复用性的View，想要对其Item做动画，需要注意以下几点： </p>
<ol>
<li>如果要一点击，让所有Item做动画的效果。例如，上图的编辑和取消，这样的动态动画。可以对所有ViewHolder中的View直接做动画。但是需要在onBindViewHolder方法中对复用的item做静态动画，保证动画状态的平滑衔接。</li>
<li>每一个Item的特有属性。例如，上图checkbox的选中状态，都需要把状态字段放到对应的Java bean中，<br>并在onBindViewHolder方法从java bean取出状态值，设置到view里。</li>
</ol>
<h1 id="1-对View的处理"><a href="#1-对View的处理" class="headerlink" title="1.对View的处理"></a>1.对View的处理</h1><p>首先，创建一个View，他是RecyclerView Item的根布局，名字为：SlideRelativeLayout，这里我们重写onFinishInflate，在View树创建完毕之后找到我们需要做动画的子View：</p>
<pre><code>@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mCheckBox = (CheckBox) findViewById(R.id.item_checkbox);
    mContentSlide = (RelativeLayout) findViewById(R.id.item_content_rl);
    setOffset(35);
}
</code></pre><p>然后，设计4个方法，分别为：<br>动态的打开动画</p>
<pre><code>@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public void openAnimation() {
    ValueAnimator valueAnimator = new ValueAnimator();
    valueAnimator.setIntValues(0, 1);
    valueAnimator.setDuration(300);
    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            float fraction = valueAnimator.getAnimatedFraction();
            int endX = (int) (-mOffset * fraction);
            doAnimationSet(endX, fraction);
        }
    });
    valueAnimator.start();
}
</code></pre><p>动态的关闭动画</p>
<pre><code>@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public void closeAnimation() {
    ValueAnimator valueAnimator = new ValueAnimator();
    valueAnimator.setIntValues(0, 1);
    valueAnimator.setDuration(150);
    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            float fraction = valueAnimator.getAnimatedFraction();
            int endX = (int) (-mOffset * (1 - fraction));
            doAnimationSet(endX, (1 - fraction));
        }
    });
    valueAnimator.start();
}
</code></pre><p>静态的打开动画</p>
<pre><code>public void open() {
    mContentSlide.scrollTo(-mOffset, 0);
}
</code></pre><p>静态的关闭动画</p>
<pre><code>public void close() {
        mContentSlide.scrollTo(0, 0);
    }
}
</code></pre><p>对子View做动画我采取的策略是：使用属性动画，在每一帧动画里获取到对应的值，对子View做相应的动画，例如：动态的打开动画，onAnimationUpdate方法，显示每一贞动画都会回调一次。</p>
<p>这样RecylerView Item带有动态动画和静态动画的View就设计好了。</p>
<h1 id="2。对ViewHolder的处理"><a href="#2。对ViewHolder的处理" class="headerlink" title="2。对ViewHolder的处理"></a>2。对ViewHolder的处理</h1><p>在bind方法中使用静态动画，动态动画对外提供方法调用</p>
<pre><code>private class SlideViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {

    private SlideRelativeLayout mSlideRelativeLayout;
    private CheckBox mCheckBox;
    private ItemBean mItemBean;

    public SlideViewHolder(View itemView) {
        super(itemView);
        mSlideRelativeLayout = (SlideRelativeLayout) itemView.findViewById(R.id.item_root);
        mCheckBox = (CheckBox) itemView.findViewById(R.id.item_checkbox);
        itemView.setOnClickListener(this);
    }

    public void bind(ItemBean itemBean) {
        mItemBean = itemBean;
        mCheckBox.setChecked(itemBean.isChecked());
        switch (mState) {
            case NORMAL:
                mSlideRelativeLayout.close();
                break;

            case SLIDE:
                mSlideRelativeLayout.open();
                break;
        }
    }

    public void openItemAnimation() {
        mSlideRelativeLayout.openAnimation();
    }

    public void closeItemAnimation() {
        mSlideRelativeLayout.closeAnimation();
    }

    public void setCheckBox() {
        mCheckBox.setChecked(!mCheckBox.isChecked());
        mItemBean.setChecked(mCheckBox.isChecked());
    }

    @Override
    public void onClick(View view) {
        setCheckBox();
    }
}
</code></pre><p>可以看到静态动画在bind里调用，打开或者关闭是由mState变量决定的。而动态的滑动需要手动调用：</p>
<p>那怎么来使用这些动画呢？ </p>
<p>动态动画的使用方法：存储所有创建出来的ViewHolder，统一调用动态动画方法。并设置mState变量值，防止滑动时动画不能平滑衔接。</p>
<pre><code>public void openItemAnimation() {
    mState = SLIDE;
    for (SlideViewHolder holder : mSlideViewHolders) {
        holder.openItemAnimation();
    }
}

public void closeItemAnimation() {
    mState = NORMAL;
    for (SlideViewHolder holder : mSlideViewHolders) {
        holder.closeItemAnimation();
    }
}
</code></pre><p>而外面又是这样调用的：</p>
<pre><code>private void editItems(){
    if (&quot;编辑&quot;.equals(mRightTV.getText().toString())) {
        mRightTV.setText(&quot;取消&quot;);
        mSlideAdapter.openItemAnimation();
    } else if (&quot;取消&quot;.equals(mRightTV.getText().toString())) {
        mRightTV.setText(&quot;编辑&quot;);
        mSlideAdapter.closeItemAnimation();
    }
}
</code></pre><p>总体就是：点击按钮 – 变量ViewHolder集合做动态动画，并设置mState变量 – 手机滑动屏幕走bind方法又是根据mState做静态动画，动画从而平滑的衔接起来。</p>
<p>动态动画起先，设置状态值，引导处理正确的静态动画，RecyclerView item的动画处理是不是变简单了。</p>
<p>还有，对item的特殊数据需要在对应的java bean里设置值，在bind方法取值设置到item中去。</p>
<h1 id="在这个过程中遇到的问题"><a href="#在这个过程中遇到的问题" class="headerlink" title="在这个过程中遇到的问题"></a>在这个过程中遇到的问题</h1><pre><code>@Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        SlideViewHolder slideViewHolder;
//        View view;
//        view=inflater.inflate(R.layout.item, parent,false);
        slideViewHolder = new SlideViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item,parent,false));
        mSlideViewHolders.add(slideViewHolder);
        return slideViewHolder;
    }
</code></pre><p>中<code>slideViewHolder = new SlideViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item,parent,false));</code><br>每次都会崩这里后来发现是XML里我自定义View的名称写错了，但是在改bug的时候并没有报错所以改了很久，然后就顺便学习了一下[什么是Context][2]我们总是用到，但是否想过Context到底是什么呢？</p>
<h2 id="2-http-www-jianshu-com-p-94e0f9ab3f1d"><a href="#2-http-www-jianshu-com-p-94e0f9ab3f1d" class="headerlink" title="  [2]: http://www.jianshu.com/p/94e0f9ab3f1d"></a>  [2]: <a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">http://www.jianshu.com/p/94e0f9ab3f1d</a></h2>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 自定义view </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 多线程]]></title>
      <url>/2017/06/06/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>在学习java的时候，你们一定对多线程这个词不陌生，而android多线程跟java相比并没有什么特殊的地方，基本都是相同的语法。<br>而线程的使用就是在执行一些耗时的操作，比如发起一条网络请求时，考虑到网速等原因，服务器不一定会立刻响应我们的请求，如果不把这些操作放在子线程中，会导致主线程被阻塞，从而影响用户对软件的正常使用。</p>
<h1 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h1><p>下面先看一下android中，三种启用线程的方法</p>
<h2 id="1-只需要新建一个类继承自Thread，然后重写父类的run-方法来实现一个线程："><a href="#1-只需要新建一个类继承自Thread，然后重写父类的run-方法来实现一个线程：" class="headerlink" title="1.只需要新建一个类继承自Thread，然后重写父类的run()方法来实现一个线程："></a>1.只需要新建一个类继承自Thread，然后重写父类的<code>run()</code>方法来实现一个线程：</h2><pre><code>public class MyThread extends Thread {  

    //继承Thread类，并改写其run方法        
    private final static String TAG = &quot;My Thread ===&gt; &quot;;      
    public void run(){  
        //具体的实现
        Log.d(TAG, &quot;run&quot;);  
        for(int i = 0; i&lt;100; i++)  
        {  
            Log.e(TAG, Thread.currentThread().getName() + &quot;i =  &quot; + i);  
        }  
    }  
} 
</code></pre><p>启动：</p>
<pre><code>new MyThread().start();
</code></pre><h2 id="2-创建一个实现Runnable接口的对象"><a href="#2-创建一个实现Runnable接口的对象" class="headerlink" title="2.创建一个实现Runnable接口的对象"></a>2.创建一个实现Runnable接口的对象</h2><pre><code>public class MyRunnable implements Runnable{  
    private final static String TAG = &quot;My Runnable ===&gt; &quot;;  

    @Override  
    public void run() {  
         //具体的逻辑
        // TODO Auto-generated method stub  
        Log.d(TAG, &quot;run&quot;);  
        for(int i = 0; i&lt;1000; i++)  
        {  
            Log.e(TAG, Thread.currentThread().getName() + &quot;i =  &quot; + i);  
        }  
    }  
} 
</code></pre><p>启动：</p>
<pre><code>new Thread(new MyRunnable()).start(); 
</code></pre><p>可以看到，<code>Thread</code>的构造函数接受一个<code>Runnable</code>参数，而我们<code>new</code>出的<code>MyRunnable</code>正是一个实现了<code>Runnable</code>接口的对象，所以可以直接将他传入到<code>Thread</code>的构造函数里。接着调用<code>Thread</code>的<code>start()</code>方法，<code>run()</code>方法中的代码就会在子线程中运行了。</p>
<h2 id="3-另外一种启用方式：匿名类（常见）"><a href="#3-另外一种启用方式：匿名类（常见）" class="headerlink" title="3.另外一种启用方式：匿名类（常见）"></a>3.另外一种启用方式：匿名类（常见）</h2><pre><code>btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                           //具体逻辑
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }).start();
            }
        });
</code></pre><p>#异步消息处理机制</p>
<h2 id="1-尝试在子线程中更新UI"><a href="#1-尝试在子线程中更新UI" class="headerlink" title="1.尝试在子线程中更新UI"></a>1.尝试在子线程中更新UI</h2><pre><code>看代码
</code></pre><p>和其他许多GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常。<br>上面这个例子就恰好证明了android确实不能在子线程中进行UI操作的，但是有些时候，我们必须在子线程中执行一些耗时任务，然后再根据执行结果来更新UI，这时候就要用到异步消息处理机制。</p>
<h2 id="2-Message，Handler，MessageQueue和Looper"><a href="#2-Message，Handler，MessageQueue和Looper" class="headerlink" title="2.Message，Handler，MessageQueue和Looper"></a>2.Message，Handler，MessageQueue和Looper</h2><pre><code>看代码
</code></pre><p><img src="http://img.blog.csdn.net/20140805002935859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Looper，Handler，message三者关系图"></p>
<h2 id="3-进一步探究Handler-Looper机制"><a href="#3-进一步探究Handler-Looper机制" class="headerlink" title="3.进一步探究Handler Looper机制"></a>3.进一步探究Handler Looper机制</h2><p>要分析Handler Looper机制，自然想到去看Handler类和Looper类的源码(分别位于Handler.java和Looper.java两个文件中)。简单阅读两个类的描述后，在Looper类的描述中能找到以下一段示例代码。</p>
<pre><code>&lt;p&gt;This is a typical example of the implementation of a Looper thread,
* using the separation of {@link #prepare} and {@link #loop} to create an
* initial Handler to communicate with the Looper.
*
* &lt;pre&gt;
*  class LooperThread extends Thread {
*      public Handler mHandler;
*
*      public void run() {
*          Looper.prepare();
*
*          mHandler = new Handler() {
*              public void handleMessage(Message msg) {
*                  // process incoming messages here
*              }
*          };
*
*          Looper.loop();
*      }
*  }&lt;/pre&gt;
*/
</code></pre><p>这段代码给出了Handler Looper机制实现进程间通信的三大基本步骤，包括Looper的两个函数prepare()和loop()，以及Handler的handleMessage函数。<br><img src="http://s3.51cto.com/wyfs02/M00/4C/6D/wKioL1Q9Ep3hhE3cAAE6NKlEbfI860.jpg" alt="Handler Looper关系总结"><br> 由图可见，基于Handler Looper机制传递消息主要包括以下几个步骤。</p>
<pre><code>(1)目标线程调用Looper.prepare()创建Looper对象和消息队列。

(2)目标线程通过new Handler()创建handler对象，将Handler,Looper，消息队列三者关联起来。并覆盖其handleMessage函数。

(3)目标线程调用Looper.loop()监听消息队列。

(4)消息源线程调用Handler.sendMessage发送消息。

(5)消息源线程调用MessageQueue.enqueueMessage将待发消息插入消息队列。

(6)目标线程的loop()检测到消息队列有消息插入，将其取出。

(7)目标线程将取出的消息通过Handler.dispatchMessage派发给Handler.handleMessage进行消息处理。
</code></pre><h2 id="4-使用AsyncTask"><a href="#4-使用AsyncTask" class="headerlink" title="4.使用AsyncTask"></a>4.使用AsyncTask</h2><p>android提供了一个很好的工具，就比如AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单的从子线程切换到主线程。<br>首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：</p>
<pre><code>1. Params
在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。
2. Progress
后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。
3. Result
当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。
</code></pre><p>因此，一个最简单的自定义AsyncTask就可以写成如下方式：</p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  
    ……  
}
</code></pre><p>这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。</p>
<p>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：</p>
<pre><code>1. onPreExecute()
这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。
2. doInBackground(Params...)
这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress...)方法来完成。
3. onProgressUpdate(Progress...)
当在后台任务中调用了publishProgress(Progress...)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。
4. onPostExecute(Result)
当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。
</code></pre><p>因此，一个比较完整的自定义AsyncTask就可以写成如下方式：</p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  

    @Override  
    protected void onPreExecute() {  
        progressDialog.show();  
    }  

    @Override  
    protected Boolean doInBackground(Void... params) {  
        try {  
            while (true) {  
                int downloadPercent = doDownload();  
                publishProgress(downloadPercent);  
                if (downloadPercent &gt;= 100) {  
                    break;  
                }  
            }  
        } catch (Exception e) {  
            return false;  
        }  
        return true;  
    }  

    @Override  
    protected void onProgressUpdate(Integer... values) {  
        progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  
    }  

    @Override  
    protected void onPostExecute(Boolean result) {  
        progressDialog.dismiss();  
        if (result) {  
            Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  
        } else {  
            Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  
        }  
    }  
}  
</code></pre><p>这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可：</p>
<pre><code>new DownloadTask().execute(); 
</code></pre><p> 如果想深入学习还是推荐研究一下源码。</p>
<p>#浅谈服务<br>Service是Android中的四大组件之一，和windows中的服务是类似，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序Service，手机中有的程序的更新，服务的推送。Android系统中，Service与Activity类似，都需要AndroidManifest.xml文件中配置，而且生命周期有点类似。Service不像Activity在前台运行，而是默默的在后台默默的工作</p>
<p><a href="http://www.cnblogs.com/xiaofeixiang/p/4077587.html" target="_blank" rel="external">浅谈Android组件之Service</a></p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 传感器开发解析]]></title>
      <url>/2017/06/06/Android-%E4%BC%A0%E6%84%9F%E5%99%A8%E5%BC%80%E5%8F%91%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Android为我们提供了传感器框架（Android sensor framework，简称ASF）可以用来访问当前Android设备内置的传感器。ASF提供了很多类和接口，帮助我们完成各种与传感器有关的任务。例如：</p>
<p>1）确定当前Android设备内置了哪些传感器。<br>2）确定某一个传感器的技术指标。<br>3）获取传感器传回来的数据，以及定义传感器回传数据的精度。<br>4）注册和注销传感器事件监听器，这些监听器用于监听传感器的变化，通常从传感器回传的数据需要利用这些监听器完成。</p>
<p>ASF允许我们访问很多传感器类型，这些传感器有一些是基于硬件的传感器，还有一些是基于软件的传感器。基于硬件的传感器就是直接以芯片形式嵌入到Android设备中，这些传感器直接从外部环境获取数据。基于软件的传感器并不是实际的硬件芯片，基于软件的传感器传回的数据本质上也来自于基于硬件的传感器，只是这些数据通常会经过二次加工。所以基于软件的传感器也可以称为虚拟（virtual）传感器或合成（synthetic）传感器。</p>
<p>Android对每个设备的传感器都进行了抽象，其中SensorManger类用来控制传感器，Sensor用来描述具体的传感器，SensorEventListener用来监听传感器值的改变。</p>
<p>（1）SensorManager类</p>
<p>用于创建sensor service的实例。该类提供了很多用于访问和枚举传感器，注册和注销传感器监听器的方法。而且还提供了与传感器精度、扫描频率、校正有关的常量。</p>
<p>（2）Sensor类</p>
<p>Sensor类为我们提供了一些用于获取传感器技术参数的方法。如版本、类型、生产商等。例如所有传感器的TYPE类型如下：<br>序号  传感器 Sensor类中定义的TYPE常量<br>1   加速度传感器  TYPE_ACCELEROMETER<br>2   温度传感器   TYPE_AMBIENT_TEMPERATURE<br>3   陀螺仪传感器  TYPE_GYROSCOPE<br>4   光线传感器   TYPE_LIGHT<br>5   磁场传感器   TYPE_MAGNETIC_FIELD<br>6   压力传感器   TYPE_PRESSURE<br>7   临近传感器   TYPE_PROXIMITY<br>8   湿度传感器   TYPE_RELATIVE_HUMIDITY<br>9   方向传感器   TYPE_ORIENTATION<br>10  重力传感器   TYPE_GRAVITY<br>11  线性加速传感器 TYPE_LINEAR_ACCELERATION<br>12  旋转向量传感器 TYPE_ROTATION_VECTOR<br>注意：1-8是硬件传感器，9是软件传感器，其中方向传感器的数据来自重力和磁场传感器，10-12是硬件或软件传感器。</p>
<p>（3）SensorEvent类</p>
<p>系统使用该类创建传感器事件对象。该对象可以提供与传感器事件有关的信息。传感器事件对象包括的信息有原始的传感器回传数据、传感器类型、数据的精度以及触发事件的时间。</p>
<p>（4）SensorEventListener接口</p>
<p>该接口包含两个回调方法，当传感器的回传值或精度发生变化时，系统会调用这两个回调方法。</p>
<pre><code>/**
* 传感器精度变化时回调
*/
@Override
public void onAccuracyChanged(Sensor sensor, int accuracy) {
}
/**
* 传感器数据变化时回调
*/
@Override
public void onSensorChanged(SensorEvent event) {
}
</code></pre><p>到了这里，我们就可以进行传感器开发工作了。</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 传感器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World——写在迁移了我的Blog之后]]></title>
      <url>/2017/06/06/hello-world/</url>
      <content type="html"><![CDATA[<p>我在2016年4月份的时候用<code>githubpages+hexo</code>搭建了自己的博客，期间积累了几篇自己的学习笔记。</p>
<p>然而良久没有更新，自己写的也不勤，然后就在2017年6月1日，我使用的<code>多说评论</code>第三方评论工具被关停了==加上我刚刚换了固态硬盘，博客配置文件丢失，所以我就趁这个机会重新换了个主题<code>next</code>，重头整理搭建我的博客。</p>
<p>六月是一个新的开始，明天就是高考过去两年，这两年的时间里我变了很多，比起当时可能我依旧很迷茫。<br>比如我现在纠结的是放弃别的事情，一心准备考研还是好好搞技术毕业去找工作。昨晚上友仔大君的话确实是对的，我不适合考研，我不适合静心去读书刷题。然而我现在的技术还很烂，去找工作自己有没有多少本事。<br>今年上半年发生了很多事情，在和组里的伙伴们做完<code>家庭助手</code>这个比赛项目之后我自己在心里给自己放了一个假。一泄气就到了今天。我想我心里有很多压力一直得不到释放，总总原因积累了很长时间。直到现在我才醒悟，旁人都开着车从我身边急驰而去，我要抓紧跟上。</p>
<p>我给自己半年时间吧，可能等半年后我才能找到自己的路。这半年弥足珍贵。</p>
<p>提醒自己，心太浮躁了。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 新的开始 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
