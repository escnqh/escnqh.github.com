<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[操作系统复习]]></title>
      <url>/2017/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><p>标签（空格分隔）： 未分类</p>
<hr>
<p>复习时听的歌</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=450041212&auto=0&height=430"></iframe>

<blockquote>
<p>主要整理了考试/考研大纲中的重点内容，根据课件笔记和一些帖子整理</p>
</blockquote>
<hr>
<h2 id="对于Hello-World程序，操作系统做了什么？"><a href="#对于Hello-World程序，操作系统做了什么？" class="headerlink" title="对于Hello World程序，操作系统做了什么？"></a>对于Hello World程序，操作系统做了什么？</h2><pre><code>#include &lt;stdio.h&gt; 
int main(int argc, char *argv[]) 
{
    printf(&quot;hello world&quot;); 
    return 0; 
 }
</code></pre><p>用户告诉操作系统执行hello程序<br>操作系统找到该程序，检查其类型<br>检查程序首部，找出正文和数据的地址<br>文件系统找到第一个磁盘块<br>父进程需要创建一个新的子进程，执行hello程序<br>操作系统需要将执行文件映射到进程结构<br>操作系统设置CPU上下文环境，并跳到程序开始处<br>程序的第一条指令执行，失败，缺页中断发生<br>操作系统分配一页内存，并将代码从磁盘读入，继续执行<br>更多的缺页中断，读入更多的页面<br>操作系统检查字符串的位置是否正确<br>操作系统找到字符串被送往的设备<br>设备是一个伪终端，由一个进程控制<br>操作系统将字符串送给该进程<br>该进程告诉窗口系统它要显示字符串<br>窗口系统确定这是一个合法的操作，然后将字符串转换 成像素<br>窗口系统将像素写入存储映像区<br>视频硬件将像素表示转换成一组模拟信号控制显示器 （重画屏幕）<br>显示器发射电子束<br>你在屏幕上看到hello world</p>
<hr>
<p>##第一章 操作系统引论</p>
<p>计算机系统的组成：<br><img src="/images/20170613194924.jpg" alt="此处输入图片的描述"><br>操作系统在计算机系统中的地位：<br><img src="/images/20170613200116.jpg" alt="此处输入图片的描述"></p>
<p>###操作系统的作用<br>操作系统通过其接口作用管理软件和硬件资源，实现了对计算机资源的抽象。</p>
<p>###操作系统发展历程<br><a href="http://baike.baidu.com/link?url=VsvbKRwY_wL4bFRE9u4pODJx31dbTEajbZZm8WaDEuxknx5ZgN6RiVLhEj7t3ltpWQlqrCJZ4DwKQCMU89Npn0C7E4kgT13eydsA6v7C1axaCtTzk7afkSWyZZNm9pdUirQ2eybDbB33LITnO-PFt9d_0BosKlJvFxUBBq-vOUi" target="_blank" rel="external">百度百科</a></p>
<p>###操作系统的基本特性</p>
<p>####<strong><em>并发(concurrency)</em></strong><br>多个事件在<strong>同一时间段</strong>内发生。操作系统是一个并发系统，各进程间的并发，系统与应用间的并发。操作系统要完成这些并发过程的管理。并行(parallel) 是指在<strong>同一时刻</strong>发生。<br>（1）在多道程序处理时，宏观上并发，<strong>微观上交替执行</strong>（在单处理器情况下，程序抢占资源啥的）（在有多个处理机时，这些由并发执行的程序便可以分配到多个处理机上，实现并行执行）；<br>（2）程序的静态实体是可执行文件，而动态实体是进程（Process）（或称作任务），并发指的是进程；<br>（3）在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O程序之间只能是顺序执行，但在为计算程序和I/O程序分别建立一个Process之后即可并发执行，极大提高了系统资源的利用率；<br>（4）进程：指在系统中能独立运行并作为资源分配的基本单位，它由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。（详细见第二章）</p>
<p>####<strong><em>共享(sharing)</em></strong><br>多个进程共享有限的计算机系统资源。操作系统要对系统资源进行合理分配和使用。资源在一个时间段内交替被多个进程所用。<br>（1）互斥共享（如视频设备）：资源分配后到释放前，不能被其他进程所用（应建立一种机制来保证这种互斥访问）；<br>（2）同时访问（磁盘文件，数据库）（单处理机环境中还是宏观概念，微观上还是交替进行）；<br>（3）资源分配难以达到最优化（问题所在）。</p>
<p>####<strong><em>虚拟(virtual)</em></strong><br>一个物理实体映射为若干个对应的逻辑实体——分时或分空间。虚拟是操作系统管理系统资源的 重要手段，可提高资源利用率。<br>在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。<br>此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。利用多道程序设计技术，把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。类似地，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上来扩充存储器的容量。因此，操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器。<br>（1）CPU——每个用户（进程）的”虚处理机”；<br>（2）存储器——每个进程都占有的地址空间（指令 ＋数据＋堆栈）</p>
<p>####<strong><em>异步性(asynchronism)</em></strong><br>也称不确定性，指进程的执行顺序和执行时间的不确定性<br>进程的运行速度不可预知：分时系统中，多个进程并发执行，程序是以走走停停的方式运行的。系统中的每个程序何时执行，执行顺序，完成时间都是 不确定的。<br>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误。<br>但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</p>
<p>###操作系统的主要功能<br>引入OS的主要目的是为多道程序的运行提供良好的运行环境。</p>
<p>####<strong><em>处理机管理</em></strong><br>完成处理机资源的分配调度等功能。处理机调度的单位可为进程或线程。<br>（1）进程控制：创建、撤销、状态转换<br>（2）进程同步：对并发执行的进程进行协调<br>常用的两种：<br>    1.进程互斥方式：为每个临界资源配置一把锁W，当锁打开时，进程可以对该临界资源进行访问；而当锁关上时，则禁止进程访问资源；<br>    2.进程同步方式：最常用的机制是信号量机制；<br>（3）进程通信：负责完成进程间的信息交换：通常采用直接通信方式，即由源进程利用发送命令直接将消息（message）挂到目标进程的消息队列（Looper？）上，以后由目标进程利用接收命令从队列中取出消息；<br>（4）进程调度：包括作业调度和进程调度（按一定算法进行处理机分配）两步；</p>
<p>####<strong><em>存储管理</em></strong><br>（1）内存分配：按一定的策略分配（以及动态分配）内存（提高利用率）并负责回收<br>（2）内存保护：保证进程间互不干扰、相互保密<br>一种简单的内存保护机制：设置两个界限寄存器，分别放在正在执行程序的上界和下界，在程序运行时，系统对每条指令的访问请求地址进行检查，如果发生越界，便发出越界中断请求，停止该程序运行；<br>（3）地址映射：进程逻辑地址到内存物理地址的映射；<br>（4）内存扩充：为允许大型作业或多个作业运行，借助<em>虚拟技术</em>获得更大逻辑内存的效果；</p>
<p>####<strong><em>设备管理</em></strong><br>（1）设备分配：为了使设备与主机并行工作，根据一定的分配原则对设备进行分配，常常采用缓冲技术和虚拟技术<br>（2）设备传输控制：实现物理的输入/输出操作<br>（3）设备独立性：用户向系统申请的设备和实际操作的设备无关</p>
<p>####<strong><em>文件管理</em></strong><br>（1）文件存储空间管理：存储空间的分配和回收<br>（2）目录管理：解决信息检索问题<br>（3）文件操作管理：实现文件的操作，负责完成数据的读写<br>（4）文件保护：提供文件保护功能，防止文件遭到破坏</p>
<p>####<strong><em>用户接口</em></strong><br>目标：提供一个友好的用户访问操作系统的接口。 操作系统向上提供两种接口：<br>（1）命令接口：提供一组命令给用户，图形化接口<br>（2）程序接口：提供一组系统调用供用户程序或其 他系统程序调用，比如库函数；</p>
<p>##第二章 操作系统的硬件环境<br>简单个人计算机中的部件：<br><img src="/images/20170614142157.jpg" alt="此处输入图片的描述"></p>
<p>###中央处理器</p>
<p>####1.CPU的构成与基本工作方式<br>处理器由运算器、控制器、一系列的寄存器以及高速缓存构成</p>
<ul>
<li>运算器实现指令中的算术和逻辑运算</li>
<li>控制器负责控制程序运行的流程</li>
<li>寄存器，它具有最快的访问速度</li>
<li>高速缓存处于CPU和物理内存之间， 访问速度快于内存，低于寄存器<br><img src="/images/20170614143604.jpg" alt="此处输入图片的描述"><br>处理器中的寄存器：有两类寄存器<br>（1）用户编程寄存器（数据寄存器，地址寄存器，条件码寄存器）<br>（2）控制状态寄存器（程序计数器PC，指令寄存器IR，程序状态字PSW，终端现场保护寄存器）<br><img src="/images/20170614143937.jpg" alt="此处输入图片的描述"><br>####2.处理器的状态与特权指令</li>
</ul>
<blockquote>
<p>管态：操作系统管理程序运行的状态，较高的特 权级别，又称为特权态（特态）、系统态<br>目态：用户程序运行时的状态，较低的特权级 别，又称为普通态（普态）、用户态<br>特权指令：只能由操作系统使用的指令</p>
</blockquote>
<p><strong><em>管态和目态的差别：</em></strong><br>处理器处于管态时：全部指令（包括特权指令）可以执行；可使用所有资源； 并具有改变处理器状态的能力 处理器处于目态时：只有非特权指令能执行。<br><strong><em>CPU状态的转换：</em></strong><br>目态——–管态：其转换的唯一途径就是通过中断<br>管态——–目态：可用设置PSW实现</p>
<p>####3.程序状态字PSW<br>特殊寄存器，用以表明处理器当前的工作状态。 通常包括以下状态码：<br>（1）CPU的工作状态码——指明管态还是目态<br>（2）条件码——反映指令执行后的结果特征<br>（3）中断屏蔽码——指出是否允许中断</p>
<p>###存储系统<br><img src="/images/20170614150801.jpg" alt="此处输入图片的描述"></p>
<p>####存储访问局部性原理<br><strong>提高存储系统效能关键点：</strong>程序存储访问局部性原理</p>
<blockquote>
<p>程序执行时，有很多的循环和子程序调用，一旦进入这样的程序段，就会重复存取相同的指令集合<br>对数据存取也有局部性，在较短的时间内，稳定地保持在一个存储器的局部区域</p>
</blockquote>
<p>处理器主要和存储器的局部打交道</p>
<p>假设两级存储器： </p>
<pre><code>第I级包含1KB，存取时间为0.1μs
第II级包含1MB，存取时间为1μs
</code></pre><p>存取I级中的内容，直接存取<br>存取II级，首先被转移到I级，然后再存取</p>
<p>若在I级存储器中发现存取对象的概率是95%，则平均访问时间为：<br><img src="/images/20170614151115.jpg" alt="此处输入图片的描述"><br>结果非常接近I级存储的存取时间</p>
<p>####存储保护（界限寄存器）<br>实现方法：</p>
<blockquote>
<p>在CPU中设置一对下限寄存器和上限寄存器存放用户作业在主存中的下限和上限地址<br>也可将一个寄存器作为基址寄存器，另一寄存器作为限长寄存器（指示存储区长度）<br>每当CPU要访问主存，硬件自动将被访问的主存地址与界限寄存器的内容进行比较，以判断是否越界<br>如果未越界，则按此地址访问主存，否则将产生程序中断——越界中断（存储保护中断）</p>
</blockquote>
<p><img src="/images/20170614151323.jpg" alt="此处输入图片的描述"><br><img src="/images/20170614151359.jpg" alt="此处输入图片的描述"></p>
<p>###中断机制<br>中断机制是操作系统得以正常工作的最重 要的手段</p>
<blockquote>
<p>它使得OS可以捕获普通程序发出的系统功能调用<br>及时处理设备的中断请求<br>防止用户程序中破坏性的活动等等</p>
</blockquote>
<p>####中断定义<br>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序<br><img src="/images/20170614151555.jpg" alt="此处输入图片的描述"></p>
<p>####引入中断的目的 </p>
<blockquote>
<p>解决主机与外设的并行工作问题<br>提高可靠性<br>实现实时控制</p>
</blockquote>
<p>特点：<br>1) 中断是随机的<br>2) 中断是可恢复的<br>3) 中断是自动处理的</p>
<p>####中断的有关概念</p>
<blockquote>
<p>中断源：引起中断发生的事件<br>中断寄存器：记录中断<br>中断字：中断寄存器的内容</p>
</blockquote>
<p>系统堆栈: 在内存开辟的一块区域，用于临时保存现场</p>
<p>##第三章</p>
]]></content>
      
        <categories>
            
            <category> 技术笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XML复习知识总结]]></title>
      <url>/2017/06/12/XML%E5%A4%8D%E4%B9%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2>java开发工具的使用</h2>

<ul>
<li>Intellij IDEA环境使用</li>
<li>Tomcat使用</li>
</ul>
<p></p><h2>xml：平台语言沟通的桥梁</h2><p></p>
<h3>校验：</h3><br>使用浏览器<br><h3>xml语法：</h3>

<pre><code>XML（eXtensible Markup Language）,可扩展标记语言。“可扩展”，即用户可以自定义标记。
</code></pre><p><img src="/images/20170612132124.jpg" alt="此处输入图片的描述"></p>
<ol>
<li>文档声明：<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;  standalone=&quot;yes&quot; ?&gt;</code><br>XML是一种元语言。<code>&lt;?xml version=“1.0”?&gt;</code>书写xml文件应注意：xml声明语句必须作为文件的第一行；</li>
<li>根标记：<br>xml有且仅有一个跟标记，其他标记必须封装在根标记中，文件的标记必须形成树状结构；</li>
<li>规范的XML：符合W3C制定的规则；</li>
<li>xml和HTML的主要区别：<br>① HTML的标记是固定的，预定义的，不可扩展的；而XML的标记是可扩展的，是可以由用户自定义的；<br>② HTML的标记说明了信息的显示格式；而XML标记表示了数据的逻辑结构及语义；</li>
<li>字符集(Charset)：<br>一组抽象字符的集合。其中字符(Character)是文字与符号的总称，包括文字、图形符号、数学符号等。英文字符集、繁体汉字字符集、日文汉字字符集；<br>被编码过的字符集(Coded Character Set) ：每种编码都限定了一个明确的字符集合；</li>
<li>ASCII：<br>美国信息交换标准码； ISO 8859，全称ISO/IEC 8859: ISO8859-1；</li>
<li>Unicode:<br>UTF-8,Unicode转换格式（Unicode Translation Format，简称UTF）；<br>Unicode的实现方式不同于编码方式。 Unicode的实现方式称为Unicode转换格式(UnicodeTranslationFormat，简称为UTF)。一个字符的Unicode编码是确定的，但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，Unicode编码的实现方式就有所不同。</li>
<li>UTF-8:大多数常用字符(ASCII中0～127字符)它只使用单字节，而对其它常用字符(特别是朝鲜和汉语会意文字)，它使用3字节；</li>
<li>汉字编码：<br>GB2312、BIG5；<br>GB2312：简体中文字符集，全称为GB2312(80)字符集，共包括国标简体汉字6763个<br>ANSI:美国国家标准局</li>
<li><code>&lt;?xml version=“1.0”encoding=“UTF-8”?&gt;</code>以“UTF-8”编码保存 默认；<br><code>&lt;?xml version=“1.0”encoding=“gb2312”?&gt;</code>以“ANSI”编码保存 ASCII、汉字；<br><code>&lt;?xml version=“1.0”encoding=“ISO-8859- 1”?&gt;</code>以“ANSI”编码保存ASCII；</li>
<li><code>&lt;!--此处为注释信息--&gt;</code>注释根标记</li>
<li>标记的命名规则：<br>必须以字母、下划线(_)或冒号(:)开头；<br>后面可以跟有效的名字符，有效名字符除了前面的，还包含数字、连接符(-)、句点(.)；<br>英文字母大小写敏感的；<br>名称不能含有空格；<br>名称中不能有字符串“xml”，“XML”或以任何顺序排列的这三个字母的组合。W3C保留对三个字母的命名的使用权；</li>
<li>五种特殊字符：<br>“ &lt; ”、“ &gt; ”、“ &amp; ”、“ ‘ ”、“ “ ”；<br>&amp;lt &lt;；&amp;gt &gt;；&amp;amp &amp;;&amp;apos ‘；&amp;quot “;</li>
<li>以“<code>&lt;![CDATA[</code>”作为段开始，以“<code>]]&gt;</code>”作为段结束，段开始和段结束之间称为CDATA段的内容。<br>CDATA段中的内容可以包含任意的字符。<br>标记内容可以由两个部分构成：文本数据部分和子标记部分。 一个标记的文本数据包括：普通字符、<br>CDATA段的内容、字符引用和实体引用。</li>
<li>名称空间：有效区分名字相同的标记；<br>名称空间声明有两种形式：<br>有前缀名称空间 ：<code>xmlns：person=“2203026”</code>；<br>无前缀名称空：<code>xmlns=“www.tup.com”</code>;<br>当且仅当它们的名字相同时称两个名称空间相同; URI只是形式上的标识符，唯一的目的是提供一个唯一的名字，并不需要指向一个有效的内容，在URI所标识的位置上，可以不存在任何东西。</li>
<li>URI（Uniform Resource Identifier），作为名称空间的名字。名称空间的名字不必是有效的，它仅仅是为了区分名称空间的名字而已;</li>
<li><p>名称空间的引用<br>（1）有前缀的名称空间：在开始标记和结束标记的名字前面添加名称空间的前缀和冒号来引用名称空间;<br>（2）无前缀的名称空间：该标记及其子标记都默认地隶属于这个名称空间;<br>（3）无前缀的名称空间：子标记也可以重新声明名称空间。</p>
<h3>xml约束：</h3>
</li>
<li><p>DTD约束：（内部约束，外部约束）<br>内部约束：直接写在xml文档中</p>
</li>
</ol>
<blockquote>
<pre><code>&lt;?xml version=”1.0” encoding=”gbk”?&gt;
&lt;!DOCTYPE 书架（根元素）[
    &lt;!ELEMENT 书架 (书+)&gt;//根元素包含的子元素书最少一个
    &lt;!ELEMENT 书 (书名,作者,售价)&gt;//子元素必须包含的子标签
    &lt;!ELEMENT 书名 (#PCDATA)&gt;//PCDATA表示元素的主体内容为普通文本
    &lt;!ELEMENT 作者 (#PCDATA)&gt;
    &lt;!ELEMENT 售价 (#PCDATA)&gt;         
]&gt;
&lt;书架&gt;
</code></pre></blockquote>
<p>外部约束：外部引入.dtd作为单独的文件存在。文件扩展名.dtd,文件必须用UTF-8编码保存到磁盘上</p>
<blockquote>
<pre><code>//dtd文件在本地：
&lt;!DOCTYPE 根元素 SYSTEM  “dtd文件的地址”&gt;
//dtd文件在外地（网上）：
&lt;!DOCTYPE 根元素 PUBLIC “dtd的名称” “dtd的路径”&gt;
//示例：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt;
&lt;!DOCTYPE TVSCHEDULE SYSTEM &quot;tet.dtd&quot;&gt;
&lt;TVSCHEDULE NAME=&quot;CCTV&quot;&gt;
    &lt;CHANNEL CHAN=&quot;zh&quot;&gt;
        &lt;BANNER&gt;文本&lt;/BANNER&gt;
        &lt;DAY&gt;
            &lt;DATE&gt;文本&lt;/DATE&gt;
            &lt;HOLIDAY&gt;文本&lt;/HOLIDAY&gt;
        &lt;/DAY&gt;
        &lt;DAY&gt;
            &lt;DATE&gt;文本&lt;/DATE&gt;
            &lt;PROGRAMSLOT&gt;
                &lt;TIME&gt;文本&lt;/TIME&gt;
                &lt;TITLE&gt;文本&lt;/TITLE&gt;
                &lt;DESCRIPTION&gt;文本&lt;/DESCRIPTION&gt;
            &lt;/PROGRAMSLOT&gt;
        &lt;/DAY&gt;
    &lt;/CHANNEL&gt;
&lt;/TVSCHEDULE&gt;
</code></pre></blockquote>
<p><strong><em>DTD语法：</em></strong><br><em>DTD的基本结构</em>：① DTD的开始标记定义元素，这是DTD中最主要注释；② 定义元素属性；<br><em>XML与DTD的关联</em>：外部DTD关联形式<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;</code>私有DTD引用<code>&lt;!DOCTYPE 根元素名SYSTEM  “DTD文件的URI&quot;&gt;</code>；<br><em>公共DTD引用</em>：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;</code> <code>&lt;!DOCTYPE 根元素名PUBLIC“DTD名称” “DTD文件的URI&quot;&gt;</code><br><strong><em>用脚本校验xml是否符合DTD约束</em></strong></p>
<ol>
<li>Schema<br>Schema语法（会读就可以）<br>名称空间，著名名称空间<br><img src="/images/20170612172737.jpg" alt="此处输入图片的描述"><br><h3>xml解析：</h3><br>程序对xml的读写，生成相应的对象<br>dom解析：只需解析一次，生成对象，但加载完整的树之后才开始解析<br>—dom4j案例</li>
</ol>
<blockquote>
<pre><code>//xml文本
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;State Code=&quot;37&quot; Name=&quot;山东&quot; description=&quot;省会&quot;&gt;
    &lt;City&gt;
        &lt;Name&gt;济南&lt;/Name&gt;
        &lt;Region&gt;历下区&lt;/Region&gt;
    &lt;/City&gt;
    &lt;City&gt;青岛&lt;/City&gt;
    &lt;City&gt;威海&lt;/City&gt;
    &lt;City&gt;泰安&lt;/City&gt;
&lt;/State&gt;
</code></pre></blockquote>
<pre><code>import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class JaxpDemo {
    public static void main(String[] args) throws Exception {   
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();//得到创建解析器的工厂：DocumentBuilderFactory
        DocumentBuilder builder = factory.newDocumentBuilder();//通过工厂得到解析器：DocumentBuilder
        Document document = builder.parse(&quot;xml文件路径&quot;);//加载xml文件：得到了Document对象    
    }
    public static void test1(Document document){//得到某个具体的节点内容
        NodeList nl = document.getElementsByTagName(&quot;City&quot;);//得到所有的City元素，
        Node node = nl.item(2);//索引从0开始
        System.out.println(node.getTextContent());//打印获得节点的主体内容
    }
    public static void test2(Document document){//遍历所有元素节点。
        Node rootNode = document.getElementsByTagName(&quot;State&quot;).item(0);
        treewalk(rootNode);
    }
    public static void treewalk(Node node){//递归
        if(node.getNodeType()==Node.ELEMENT_NODE){//是一个元素节点
            System.out.println(node.getNodeName());//打印元素的名称
        }
        NodeList nl = node.getChildNodes();//看看他有没有孩子
        for(int i=0;i&lt;nl.getLength();i++){
            Node n = nl.item(i);
            treewalk(n);//递归
        }
    }
    public static void test3(Document document) throws Exception{//修改某个元素节点的主体内容
        Node secondCityNode = document.getElementsByTagName(&quot;City&quot;).item(1);//找到第2个City元素
        secondCityNode.setTextContent(&quot;威海&quot;);//设置主体内容为：威海
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test4(Document document) throws Exception{//向指定元素节点中增加子元素节
        Element e = document.createElement(&quot;City&quot;);//&lt;City&gt;&lt;/City&gt;//创建新元素
        e.setTextContent(&quot;烟台&quot;);//&lt;City&gt;烟台&lt;/City&gt;
        Node rootNode = document.getElementsByTagName(&quot;State&quot;).item(0);
        rootNode.appendChild(e);//把新元素添加到State最后
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test5(Document document) throws Exception{//向指定元素节点上增加同级元素节点
        Element e = document.createElement(&quot;City&quot;);//创建新元素
        e.setTextContent(&quot;青岛&quot;);
        //调用inertBefore插入新节点：必须由父节点来调用
        Node secondNode = document.getElementsByTagName(&quot;City&quot;).item(1);
        secondNode.getParentNode().insertBefore(e, secondNode);
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test6(Document document) throws Exception{//删除指定元素节点
        Node ytNode = document.getElementsByTagName(&quot;City&quot;).item(4);//得到烟台节点
        ytNode.getParentNode().removeChild(ytNode);//用父节点删除 
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
    public static void test7(Document document) throws Exception{//操作XML文件属性
        Node stateNode = document.getElementsByTagName(&quot;State&quot;).item(0);//看成元素
        if(stateNode.getNodeType()==Node.ELEMENT_NODE){
            Element e = (Element)stateNode;
            System.out.println(e.getAttribute(&quot;Name&quot;));
        }
    }
    public static void test8(Document document) throws Exception{//8、添加属性
        Node stateNode = document.getElementsByTagName(&quot;State&quot;).item(0);//看成元素
        if(stateNode.getNodeType()==Node.ELEMENT_NODE){
            Element e = (Element)stateNode;
            e.setAttribute(&quot;description&quot;, &quot;省会&quot;);
        }
        //把内存中的Document写到xml文件中
        TransformerFactory tf = TransformerFactory.newInstance();
        Transformer ts = tf.newTransformer();
        ts.transform(new DOMSource(document), new StreamResult(&quot;src/LocList.xml&quot;));
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 技术笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> XML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用OkHttp]]></title>
      <url>/2017/06/11/%E4%BD%BF%E7%94%A8OkHttp/</url>
      <content type="html"><![CDATA[<p>首先就是导依赖：</p>
<pre><code>compile &apos;com.zhy:okhttputils:2.0.0&apos;
</code></pre><h2 id="HttpURLConnection和OkHttp的比较"><a href="#HttpURLConnection和OkHttp的比较" class="headerlink" title="HttpURLConnection和OkHttp的比较"></a>HttpURLConnection和OkHttp的比较</h2><pre><code>● HttpURLConnection有的API，OkHttp基本上都有（你有我有全都有呀，哈哈哈）
● HttpURLConnection和OkHttp都支持Https，流的上传和下载，超时，IP6、连接池等等
● OkHttp比HttpURLConnection具有更好的同步异步请求、缓存机制，支持HttpDNS、重定向、Gzip压缩，平台适应性、很好的服务器IP的转换、直接Socket通信，支持拦截器等等。
</code></pre><p>看到这么多机制，是不是觉得很强大，通过Socket直接通信，以及很好的缓存机制，Gzip对于Http头部的压缩传输。自然对于网络请求这块使应用更加省流量、请求的更快。OkHttp对于Https和HttpDNS的支持，使得应用的网络通信安全性更高。当然说了它的好，现在也来说说它的不好之处：</p>
<pre><code>● OkHttp不支持优先级请求
● OkHttp不支持自签名证书
● OkHttp header中不能传中文
</code></pre><p>虽然是不好的地方，但是OkHttp已经比较成熟了，网上解决这几个问题的资料也很多了。所以这些都不是问题。</p>
<h2 id="一个简单的Get请求例子"><a href="#一个简单的Get请求例子" class="headerlink" title="一个简单的Get请求例子"></a>一个简单的Get请求例子</h2><p>这里我们就以经典的官网提供的Get请求的例子来学习下，说大概的代码。<br>  ● 先在manifest加个网络权限，养成良好习惯</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre><p>然后在build.gradle文件的dependencies添加库如下：</p>
<pre><code>dependencies {
    compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos;
    compile &apos;com.squareup.okio:okio:1.7.0&apos;
}
</code></pre><p>同步Get请求：</p>
<pre><code>final OkHttpClient okHttpClient = new OkHttpClient()
           .newBuilder()
           .build();
   final Request request = new Request.Builder()
           .url(&quot;https://www.publicobject.com/helloworld.txt&quot;)
           .header(&quot;User-Agent&quot;,&quot;OkHttp Example&quot;)
           .build();
   new Thread(new Runnable() {
       @Override
       public void run() {
           try {
               Response response = okHttpClient.newCall(request).execute();
               Log.d(&quot;zgx&quot;,&quot;response=====&quot;+response.body().string());
               response.body().close();
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   }).start();
</code></pre><h2 id="一些基本的知识"><a href="#一些基本的知识" class="headerlink" title="一些基本的知识"></a>一些基本的知识</h2><ul>
<li>Http</li>
</ul>
<p>Http是一种基于TCP/IP连接的一套网络通信协议，它是一种一应一答的请求，它分为Get和Post请求，Get请求获取得是静态页面，它可以把参数放在URL字符串后面。而Post请求就不同了，它是把参数放在Http请求的正文的。<br>Get请求我们会这样请求：</p>
<pre><code>private void HttpURLConnection_Get(){  
        try{  
            //通过openConnection 连接  
            URL url = new java.net.URL(URL);  
            urlConn=(HttpURLConnection)url.openConnection();  
            //设置输入和输出流   
            urlConn.setDoOutput(true);  
            urlConn.setDoInput(true);  
            //关闭连接  
            urlConn.disconnect();  
        }catch(Exception e){  
            resultData = &quot;连接超时&quot;;  
        }  
    } 
</code></pre><p>然后把获取到的urlConn连接的数据通过IO流把读取出来：</p>
<pre><code>InputStreamReader in = new InputStreamReader(urlConn.getInputStream());    
                   BufferedReader buffer = new BufferedReader(in);    
                   String inputLine = null;    
                   while (((inputLine = buffer.readLine()) != null)){  
                       resultData += inputLine + &quot;\n&quot;;    
                   }  
                   System.out.println(resultData);  
                   in.close();
</code></pre><p>Post请求则会这样：</p>
<pre><code>private void HttpURLConnection_Post(){  
      try{  
          //通过openConnection 连接  
          URL url = new java.net.URL(URL_Post);  
          urlConn=(HttpURLConnection)url.openConnection();  
          //设置输入和输出流   
          urlConn.setDoOutput(true);  
          urlConn.setDoInput(true);  

          urlConn.setRequestMethod(&quot;POST&quot;);  
          urlConn.setUseCaches(false);  
          // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的    
          urlConn.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    
          // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  
          // 要注意的是connection.getOutputStream会隐含的进行connect。    
          urlConn.connect();  
          //DataOutputStream流  
          DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  
          //要上传的参数  
          String content = &quot;par=&quot; + URLEncoder.encode(&quot;ylx_Post+中正&quot;, &quot;UTF_8&quot;);   
          //将要上传的内容写入流中  
          out.writeBytes(content);     
          //刷新、关闭  
          out.flush();  
          out.close();     

      }catch(Exception e){  
          resultData = &quot;连接超时&quot;;  
      }  
  } 
</code></pre><p>然后同上把获取到的urlConn连接的数据通过IO流把读取出来，大概的代码就是这样。</p>
<ul>
<li>缓存处理</li>
</ul>
<p>先来看看OkHttp的缓存怎么设置</p>
<pre><code>int cacheSize = 10 * 1024 * 1024; // 10 MiB
  //cacheDirectory保存缓存的目录，cacheSize缓存空间的大小
  Cache cache = new Cache(context.getCacheDir(), cacheSize);
  final OkHttpClient okHttpClient = new OkHttpClient()
          .newBuilder()
          .cache(cache)
          .build();
</code></pre>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Retrofit框架]]></title>
      <url>/2017/06/07/%E4%BD%BF%E7%94%A8Retrofit%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>先添加几个权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre><p>build.gradle添加依赖，下面会用到的也在这里了：</p>
<pre><code>compile &apos;com.android.support:appcompat-v7:23.4.0&apos;
compile &apos;com.android.support:design:23.4.0&apos;
compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;
compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;
compile &apos;com.squareup.okhttp3:okhttp:3.3.0&apos;
compile &apos;com.squareup.okio:okio:1.7.0&apos;
 compile &apos;com.squareup.okhttp3:logging-interceptor:3.2.0&apos;
compile &apos;io.reactivex:rxandroid:1.1.0&apos;
compile &apos;io.reactivex:rxjava:1.1.0&apos;
compile &apos;com.android.support:recyclerview-v7:23.4.0&apos;
</code></pre><p>两个retrofit依赖包，两个okhttp依赖包，okhttp3:logging-interceptor依赖包主要是拦截请求日志使用，引入下面 要使用的rxandroid的两个依赖包reactivex:rxandroid和reactivex:rxjava，recyclerview主要是新 闻列表页要使用的。</p>
<h2 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h2><p>页面写好了。下面我们通过单例形式创建一个Retrofit对象。</p>
<pre><code>public class HRetrofitNetHelper{
    public static HRetrofitNetHelper mInstance;
    public Retrofit mRetrofit;
    //本地ip为192.168.1.103
    public static final String BASE_URL = &quot;http://192.168.1.103:8080/GoachWeb/&quot;;
    private HRetrofitNetHelper(){
        mRetrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .build();
    }
    public static HRetrofitNetHelper getInstance(){
        if(mInstance==null){
            synchronized (HRetrofitNetHelper.class){
                if(mInstance==null)
                    mInstance = new HRetrofitNetHelper ();
            }
        }
        return mInstance ;
    }
}
</code></pre><p>简单的创建好了一个Retrofit。这里只是配置了一个接口的baseUrl，也就是根路径。</p>
<h2 id="配置ConverterFactory"><a href="#配置ConverterFactory" class="headerlink" title="配置ConverterFactory"></a>配置ConverterFactory</h2><p>如果要Retrofit直接将json转换为为Dao对象。那么我们就要通过addConverterFactory来配置，如下：</p>
<pre><code>mRetrofit = new Retrofit.Builder()
               .addConverterFactory(GsonConverterFactory.create())
               .build();
</code></pre><p>上面是使用依赖：<code>compile&#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;</code>包。然后<code>addConverterFactory</code>来配置。通过源码方法<code>addConverterFactory(Converter.Factory factory)</code>我们可以看到要传入一个继承Converter.Factory的对象。Retrofit里面就有这样的对象，这里我们用的是Gson来进行解析，那就有对应的GsonConverterFactory。那好下面就来创建这个对象</p>
<p>创建这个对象有两种方式</p>
<ul>
<li>一种是像上面写的一样</li>
</ul>
<p>GsonConverterFactory.create()<br>这种方式就是简单的创建默认的Gson对象，然后像我们平常一样转换为Dao对象。</p>
<ul>
<li>还有一种方式就是通过GsonBuilder创建Gson对象</li>
</ul>
<p>比如这里统一把后台提供的带有yyyy-MM-dd HH:mm:ss格式的Date对象，客户端如果用上面这种方式创建的话，会报下面这个错</p>
<pre><code>java.text.ParseException: Failed to parse date [&quot;2016-06-11 20:57:28&apos;]: Invalid time zone indicator &apos; &apos; (at offset 0)
</code></pre><p>这种情况下，我们就可以这样：</p>
<pre><code>Gson mGson = new GsonBuilder()
                .setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create();
然后再创建GsonConverterFactory对象的时候传入Gson
.addConverterFactory(GsonConverterFactory.create(mGson))
</code></pre><p>就可以很好的解决这个问题了。</p>
<p>这里只是说了使用Gson进行解析，其实Retrofit还提供了其他的一些解析工具，如下：</p>
<pre><code>Gson: com.squareup.retrofit2:converter-gson
Jackson: com.squareup.retrofit2:converter-jackson
Moshi: com.squareup.retrofit2:converter-moshi
Protobuf: com.squareup.retrofit2:converter-protobuf
Wire: com.squareup.retrofit2:converter-wire
Simple XML: com.squareup.retrofit2:converter-simplexml
Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars
</code></pre><p>用法类似这样：<br>导入包(xx可以指Jackson或者Moshi等等)：<code>compile &#39;com.squareup.retrofit2:converter-xx:2.0.2&#39;</code>然后：<code>.addConverterFactory(xxConverterFactory.create(mGson))</code></p>
<p>当然，我们还是可以设置多个<code>converter</code>比如支持 proto 格式和json格式。那么如下添加：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      //...
    .addConverterFactory(ProtoConverterFactory.create())
    .addConverterFactory(GsonConverterFactory.create())
    .build();
</code></pre><p><code>ProtoConverterFactory</code>和<code>GsonConverterFactory</code>添加 <code>converter</code> 的顺序很重要。Retrofit会依次询问每一个 converter 能否处理一个类型。当Retrofit试图反序列化一个 proto 格式，它其实会被当做 JSON 来对待。所以Retrofit会先要检查 proto buffer 格式，然后才是 JSON。所以要先添加ProtoConverterFactory，然后是GsonConverterFactory。<br>又比如我们需要Retrofit支持RxJava。添加：</p>
<pre><code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre><p>就好了。</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ButterKnife的使用]]></title>
      <url>/2017/06/07/ButterKnife%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h2><pre><code>-- 项目地址：https://github.com/Jak eWharton/butterknife
</code></pre><p>都说程序员都是比较懒的，什么事情都想着让程序自动化帮忙减轻工作量，这个开源库可以让我们从大量的<code>findViewById()和setonclicktListener()</code>解放出来，其对性能的影响微乎其微（查看过Butter Knife的源码，其自定义注解的实现都是限定为RetentionPolicy.CLASS，也就是到编译出.class文件为止有效，在运行时不额外消耗性能，其是通过java注解自动生成java代码的形式来完成工作），其也有一个明显的缺点，那就是代码的可读性差一些，但了解了之后，上手也很快。。。</p>
<h2 id="解放控件对象实例化"><a href="#解放控件对象实例化" class="headerlink" title="解放控件对象实例化"></a>解放控件对象实例化</h2><p>也就是 findViewById()，一直以来的做法都是一个个定义，然后在 setContentView() 或 inflate() 之后一一来findViewById()进行实例化，而使用 ButterKnife，你只需要在代码中 使用注解方式进行对象申明，然后在 setContentView() 或 inflate() 之后调用一句话，那么申明的所有对象自动创建出来。</p>
<pre><code> 1     @InjectView(R.id.ok_btn) //控件对应的ID
 2     Button mBtn;
 3 
 4     @InjectView(R.id.title_text)
 5     TextView mTitleTextView;
 6 
 7     @Override
 8     protected void onCreate(Bundle savedInstanceState) {
 9         super.onCreate(savedInstanceState);
10         setContentView(R.layout.main_activity);
11 
12         ButterKnife.inject(this);
13 
14         //这样之后就可以直接使用变量了
15         mTitleTextView.setText(&quot;test&quot;);
16 
17     }
</code></pre><p>是不是很神奇！！！<br>Fragment的和adapter里也可以用，不过调用时要多加一个root view参数。<br>Fragegment使用时记得同时继承onDestroyView，并在其中将ButterKnife.reset</p>
<pre><code> 1 public class FancyFragment extends Fragment {
 2   @InjectView(R.id.button1) Button button1;
 3   @InjectView(R.id.button2) Button button2;
 4 
 5   @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 6     View view = inflater.inflate(R.layout.fancy_fragment, container, false);
 7     ButterKnife.inject(this, view);
 8     // TODO Use &quot;injected&quot; views...
 9     return view;
10   }
11 }
12 
13   @Override void onDestroyView() {
14     super.onDestroyView();
15     ButterKnife.reset(this);
16   }
</code></pre><p>还可以实例化控件数组，注解多一个s，也就是 InjectViews</p>
<pre><code>1 @InjectViews({ R.id.first_name, R.id.middle_name, R.id.last_name }) List&lt;EditText&gt; nameViews;
</code></pre><p>解放监听添加<br>如下，可以直接为 R.id.submit这个控件添加OnClickListener为submit函数，流弊啊。。。</p>
<pre><code>1 @OnClick(R.id.submit)
2 public void submit() {
3   // TODO submit data to server...
4 }
还可以批量为多个控件添加为同一个响应函数：

1 @OnClick({ R.id.door1, R.id.door2, R.id.door3 })
2   public void pickDoor(DoorView door) {
3    if (door.hasPrizeBehind()) {
4         Toast.makeText(this, &quot;You win!&quot;, LENGTH_SHORT).show();
5    } else {
6        Toast.makeText(this, &quot;Try again&quot;, LENGTH_SHORT).show();
7    }
8   }
</code></pre><p>具体的可以去看该大神的项目页面。在文前已给出。<br>注：最新版的库已经将方法名改了，当然也是兼容上面所列的例子的。最新示例如下：</p>
<pre><code>1 class ExampleActivity extends Activity {
 2   @FindView(R.id.user) EditText username;
 3   @FindView(R.id.pass) EditText password;
 4 
 5   @OnClick(R.id.submit) void submit() {
 6     // TODO call server...
 7   }
 8 
 9   @Override public void onCreate(Bundle savedInstanceState) {
10     super.onCreate(savedInstanceState);
11     setContentView(R.layout.simple_activity);
12     ButterKnife.bind(this);
13     // TODO Use fields...
14   }
15 }
</code></pre>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 依赖插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[handler和AsyncTask学习笔记]]></title>
      <url>/2017/06/07/handler%E5%92%8CAsyncTask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="AsyncTask实现的原理和适用的优缺点"><a href="#AsyncTask实现的原理和适用的优缺点" class="headerlink" title="AsyncTask实现的原理和适用的优缺点"></a>AsyncTask实现的原理和适用的优缺点</h2><p>AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.</p>
<ol>
<li><p>使用的优点:</p>
<p>简单，快捷，过程可控 </p>
</li>
</ol>
<ol>
<li><p>使用的缺点:</p>
<p>在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.</p>
</li>
</ol>
<h2 id="Handler异步实现的原理和适用的优缺点"><a href="#Handler异步实现的原理和适用的优缺点" class="headerlink" title="Handler异步实现的原理和适用的优缺点"></a>Handler异步实现的原理和适用的优缺点</h2><p>在Handler 异步实现时,涉及到 <code>Handler, Looper, Message,Thread</code>四个对象，实现异步的流程是主线程启动Thread（子线程）运行并生成Message-Looper获取Message并传递给HandlerHandler逐个获取Looper中的Message，并进行UI变更。</p>
<ol>
<li><p>使用的优点：</p>
<p>结构清晰，功能定义明确<br>对于多个后台任务时，简单，清晰</p>
</li>
<li><p>使用的缺点：</p>
<p> 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）</p>
</li>
</ol>
<h2 id="AsyncTask介绍"><a href="#AsyncTask介绍" class="headerlink" title="AsyncTask介绍"></a>AsyncTask介绍</h2><p>Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。<br>首先明确Android之所以有Handler和AsyncTask，都是为了不阻塞主线程（UI线程），且UI的更新只能在主线程中完成，因此异步处理是不可避免的。</p>
<p>Android为了降低这个开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，顾名思义就是异步任务。<br>AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法(至少重载一个)。</p>
<p>AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>
<pre><code>  ● Params 启动任务执行的输入参数，比如HTTP请求的URL。
  ● Progress 后台任务执行的百分比。
  ● Result 后台执行任务最终返回的结果，比如String。
使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：
  ● doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。
  ● onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回
有必要的话你还得重写以下这三个方法，但不是必须的：
  ● onProgressUpdate(Progress…)   可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。
  ● onPreExecute()        这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。
  ● onCancelled()             用户调用取消时，要做的操作
使用AsyncTask类，以下是几条必须遵守的准则：
  ● Task的实例必须在UI thread中创建；
  ● execute方法必须在UI thread中调用；
  ● 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几个方法；
  ● 该task只能被执行一次，否则多次调用时将会出现异常；
</code></pre><h2 id="Handler介绍"><a href="#Handler介绍" class="headerlink" title="Handler介绍"></a>Handler介绍</h2><ol>
<li><p>Handler主要接受子线程发送的数据, 并用此数据配合主线程更新UI.</p>
<p>当应用程序启动时，Android首先会开启一个主线程,主线程为管理界面中的UI控件，进行事件分发,更新UI只能在主线程中更新，子线程中操作是危险的。这个时候，Handler就需要出来解决这个复杂的问题。由于Handler运行在主线程中(UI线程中),它与子线程可以通过Message对象来传递数据, 这个时候，Handler就承担着接受子线程传过来的(子线程用sedMessage()方法传递)Message对象(里面包含数据), 把这些消息放入主线程队列中，配合主线程进行更新UI。</p>
</li>
<li><p>Handler的特点</p>
<p>Handler可以分发Message对象和Runnable对象到主线程中,每个Handler实例,都会绑定到创建他的线程中,它有两个作用:</p>
<p> (1)安排消息或Runnable 在某个主线程中某个地方执行<br> (2)安排一个动作在不同的线程中执行</p>
</li>
<li><p>Handler中分发消息的一些方法</p>
<p>post(Runnable)<br>postAtTime(Runnable,long)<br>postDelayed(Runnable long)<br>sendEmptyMessage(int)<br>sendMessage(Message)<br>sendMessageAtTime(Message,long)<br>sendMessageDelayed(Message,long)</p>
</li>
</ol>
<p>以上post类方法允许你排列一个Runnable对象到主线程队列中,sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新。</p>
<p>综上所述：数据简单使用AsyncTask:实现代码简单，数据量多且复杂使用handler+thread:相比较AsyncTask来说能更好的利用系统资源且高效</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> android基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Blog中添加音乐]]></title>
      <url>/2017/06/06/%E5%9C%A8Blog%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/</url>
      <content type="html"><![CDATA[<p>在Blog中添加音乐播放器有两种，一种是歌单另一种是在一篇文章中插入歌曲，以网易云为例介绍一下这两种方法</p>
<h2 id="歌单或者单曲播放器"><a href="#歌单或者单曲播放器" class="headerlink" title="歌单或者单曲播放器"></a>歌单或者单曲播放器</h2><p>这种播放器依靠网易云音乐生成的外链播放器</p>
<p><img src="/images/20170606211501.jpg" alt="此处输入图片的描述"></p>
<p><img src="/images/20170606212001.jpg" alt="此处输入图片的描述"></p>
<p><img src="/images/20170606211330.jpg" alt="此处输入图片的描述"></p>
<p>代码如下：</p>
<pre><code>&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=427685783&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;
</code></pre><p>效果如下，可以在Blog相应的位置中添加代码段即可显示播放器效果，修改歌单只需要在网易云音乐中将相应的歌单修改即可。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=427685783&auto=0&height=430"></iframe>

<p>嘿嘿其实这里有一个坑就是你拿到我上面的示例代码后直接粘贴会发现音乐是自动播放的，其实在代码中将<code>auto=1</code>属性改为<code>auto=0</code>即可。<br>或者，直接在生成外链播放器时把自动播放取消。</p>
<p>相应的，单首歌也可以用这种方法生成播放器，插入到文章中。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5054922&auto=0&height=66"></iframe>

<p>文章最后送大家一首Notting Hill中的Ain’t no sunshine。</p>
<p>ps:由于版权原因可能有的歌单和单曲不能生成播放。</p>
]]></content>
      
        <categories>
            
            <category> 技术闲谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_Collection]]></title>
      <url>/2017/06/06/Java-Collection/</url>
      <content type="html"><![CDATA[<h2 id="Collection层次结构"><a href="#Collection层次结构" class="headerlink" title="Collection层次结构"></a>Collection层次结构</h2><p><img src="http://img.blog.csdn.net/20130821151227718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRsd2M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Collection层次结构"></p>
<p><img src="http://my.csdn.net/uploads/201206/02/1338603398_8372.jpg" alt="Collection层次结构"></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><pre><code>子接口  
    Set,List  
集合中只能放置对象的引用,不能放置原生数据类型,  
    我们需要使用原生数据类型的封装类才能加入到集合中  
</code></pre><h2 id="Ordered与Sorted接口"><a href="#Ordered与Sorted接口" class="headerlink" title="Ordered与Sorted接口"></a>Ordered与Sorted接口</h2><pre><code>Ordered排序,按照某种由具体情况决定的顺序排序,是后天指定的  
Sorted排序,按照天然顺序进行排序,是先天指定的  
</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre><code>实现类包括  
    LinkedList,Vector,ArrayList  
列表接口,继承与Collection,可以按索引的顺序访问,有索引的Collection  
    具有列表的功能,元素顺序均是按添加的先后进行排列的,  
    允许重复的元素,允许多个null元素  
</code></pre><h2 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        List list = new ArrayList();  
        // 向列表的尾部追加指定的元素  
        list.add(&quot;lwc&quot;);  
        // 在列表的指定位置插入指定元素  
        list.add(1, &quot;nxj&quot;);  
        // 追加指定 collection 中的所有元素到此列表的结尾  
        list.addAll(new ArrayList());  
        // 从列表中移除所有元素  
        list.clear();  
        // 如果列表包含指定的元素,则返回true  
        list.contains(&quot;nxj&quot;);  
        // 如果列表包含指定 collection 的所有元素,则返回 true  
        list.containsAll(new ArrayList());  
        // 比较指定的对象与列表是否相等  
        list.equals(new ArrayList());  
        // 返回列表中指定位置的元素  
        list.get(0);  
        // 返回列表的哈希码值  
        list.hashCode();  
        // 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1  
        list.indexOf(&quot;lwc&quot;);  
        // 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1  
        list.lastIndexOf(&quot;lwc&quot;);  
        // 如果列表不包含元素,则返回 true  
        list.isEmpty();  
        // 移除列表中指定位置的元素  
        list.remove(0);  
        // 移除列表中出现的首个指定元素  
        list.remove(&quot;lwc&quot;);  
        // 从列表中移除指定 collection 中包含的所有元素  
        list.removeAll(new ArrayList());  
        // 用指定元素替换列表中指定位置的元素  
        list.set(0, &quot;lp&quot;);  
        // 返回列表中的元素数  
        list.size();  
        // 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图  
        list.subList(1, 2);  
        // 返回以正确顺序包含列表中的所有元素的数组  
        list.toArray();  
        // 返回以正确顺序包含列表中所有元素的数组  
        list.toArray(new String[] { &quot;a&quot;, &quot;b&quot; });  
    }  
}  
</code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><pre><code>构造方法  
    public ArrayList()  
    public ArrayList(int initialCapacity)  
    public ArrayList(Collection c)  
ArrayList依赖于数组实现的,初始长度为10的Object[],并且可随需要而增加的动态数组  
    当元素超过10,那么ArrayList底层会新生成一个数组,长度为原来的1.5倍+1,  
    然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,  
    当新数组无法容纳增加的元素,重复该过程  
ArrayList对随机访问性能很好,但进行大量插入,删除操作,性能很差,  
    因为操作之后后续元素需要移动  
</code></pre><h2 id="遍历ArrayList"><a href="#遍历ArrayList" class="headerlink" title="遍历ArrayList"></a>遍历ArrayList</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.Iterator;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();  
        list.add(&quot;lwc&quot;);  
        list.add(&quot;nxj&quot;);  
        // 方法一  
        Iterator&lt;String&gt; ite1 = list.iterator();  
        while (ite1.hasNext()) {  
            String str = ite1.next();  
            System.out.println(str);  
        }  
        System.out.println(&quot;---------------------&quot;);  
        // 方法二(方法一的变形)  
        for (Iterator&lt;String&gt; ite2 = list.iterator(); ite2.hasNext();) {  
            String str = ite2.next();  
            System.out.println(str);  
        }  
        System.out.println(&quot;---------------------&quot;);  
        // 方法三  
        for(String s : list){  
            System.out.println(s);  
        }  
    }  
}  
/* 
打印结果: 
    lwc 
    nxj 
    --------------------- 
    lwc 
    nxj 
    --------------------- 
    lwc 
    nxj 
*/  
</code></pre><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><pre><code>向量,历史比较悠久,Java诞生就有了,特点与ArrayList相同,  
    不同的是Vector操作元素的方法是同步的,同一时刻只能有一个线程访问,没有特殊需求都使用ArrayList  
构造方法  
    public Vector()  
    public Vector(int initialCapacity)  
    public Vector(int initialCapacity,int capacityIncrement)  
        第一个参数是初始容量,第二个参数是当Vector满时的增量  
    public Vector(Collection c)  
Vector也是依赖数组实现的 
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;  

import java.util.Enumeration;  
import java.util.Vector;  

public class Test {  
    public static void main(String[] args) {  
        Vector v = new Vector();  
        v.add(&quot;123&quot;);  
        v.add(&quot;lwc&quot;);  
        v.add(&quot;你好&quot;);  
        // Vector转换为枚举  
        Enumeration e = v.elements();  
        while (e.hasMoreElements()) {  
            System.out.println(e.nextElement());  
        }  
    }  
}
</code></pre><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><pre><code>Vector的子类
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;

import java.util.Enumeration;  
import java.util.Stack;  

public class Test {  
    public static void main(String[] args) {  
        Stack stack = new Stack();  
        // 向栈里面压一个整数  
        stack.push(new Integer(123));  
        stack.push(&quot;lwc&quot;);  
        stack.push(new Double(88.88));  
        // 遍历  
        Enumeration items = stack.elements();  
        while (items.hasMoreElements()) {  
            System.out.print(items.nextElement() + &quot; &quot;);  
        }  
        System.out.println();  
        // 出栈  
        while (stack.size() != 0) {  
            System.out.print(stack.pop() + &quot; &quot;);  
        }  
    }  
}  
/* 
打印结果: 
    123 lwc 88.88  
    88.88 lwc 123 
*/  
</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><pre><code>LinkedList功能与ArrayList,Vector相同,内部是依赖双链表实现的,  
    因此有很好的插入和删除性能,但随机访问元素的性能很差  
构造方法  
    public LinkedList()  
    public LinkedList(Collection c)  
LinkedList类中有一个Entry内部类,Entry内部类包含3个部分向前的引用,向后的引用,数据  
    header.next = header.previous = header;  
</code></pre><h2 id="遍历LinkedList"><a href="#遍历LinkedList" class="headerlink" title="遍历LinkedList"></a>遍历LinkedList</h2><pre><code>package com.itlwc;  

import java.util.LinkedList;  
import java.util.List;  
import java.util.ListIterator;  

public class Test {  
    public static void main(String[] args) {  
        List link = new LinkedList();  
        link.add(123);  
        link.add(&quot;lwc&quot;);  
        link.add(8.8);  
        link.add(&quot;nxj&quot;);  
        link.add(520);  
        printList(link);  
        printReversedList(link);  
    }  


private static void printList(List link) {  
    System.out.println(&quot;正序链表中的元素&quot;);  
    // 的到链表的迭代器,位置指向链头  
    ListIterator li = link.listIterator();  
    // 判断迭代器中是否有下一个元素  
    while (li.hasNext()) {  
        // 返回下个元素  
        System.out.print(li.next() + &quot; &quot;);  
    }  
    System.out.println();  
}  

private static void printReversedList(List link) {  
    System.out.println(&quot;逆向链表中的元素&quot;);  
    // 的到链表的迭代器,位置指向link.size()结尾  
    ListIterator li = link.listIterator(link.size());  
    // 判断迭代器中是否有前一个元素  
    while (li.hasPrevious()) {  
        // 返回前一个元素  
        System.out.print(li.previous() + &quot; &quot;);  
    }  
    System.out.println();  
}  
}  
/* 
打印结果: 
    正序链表中的元素 
    123 lwc 8.8 nxj 520  
    逆向链表中的元素 
    520 nxj 8.8 lwc 123  
*/
</code></pre><h2 id="自定义LinkedList结构"><a href="#自定义LinkedList结构" class="headerlink" title="自定义LinkedList结构"></a>自定义LinkedList结构</h2><pre><code>package com.itlwc;  

class Node {  
    Node previous;// 前驱  
    String data;// 数据  
    Node next;// 后驱  

    public Node(String data) {  
        this.data = data;  
    }  
}  

public class Test {  
    public static void main(String[] args) {  
        Node node1 = new Node(&quot;node1&quot;);  
        Node node2 = new Node(&quot;node2&quot;);  
        Node node3 = new Node(&quot;node3&quot;);  
        node1.next = node2;  
        node2.previous = node1;  
        node2.next = node3;  
        node3.previous = node2;  
        node3.next = node1;  
        node1.previous = node3;  

        // 增加node4  
        Node node4 = new Node(&quot;node4&quot;);  
        node1.next = node4;  
        node4.previous = node1;  
        node4.next = node2;  
        node2.previous = node4;  
        // 删除node4  
        node1.next = node2;  
        node2.previous = node1;  
        node4.previous = null;  
        node4.next = null;  

    }  
}  
</code></pre><h2 id="依赖倒置原理"><a href="#依赖倒置原理" class="headerlink" title="依赖倒置原理"></a>依赖倒置原理</h2><pre><code>依赖应该尽量在抽象层进行,避免在具体层进行,  
    在实际开发中尽量使用接口类型的引用,避免采用具体类型的引用  
</code></pre><p>案例：</p>
<pre><code>package com.itlwc;  

import java.util.LinkedList;  
import java.util.List;  

public class Test {  
    //如果我们需要传入参数是ArrayList就需要改动代码  
    public void printLinkedList(LinkedList ll){  
        System.out.println(ll);  
    }  
    //如果我们传入参数是List的子类,我们不需要改动代码,灵活性大  
    public void printList(List l){  
        System.out.println(l);  
    }  
}
</code></pre><h2 id="将数组转换为列表"><a href="#将数组转换为列表" class="headerlink" title="将数组转换为列表"></a>将数组转换为列表</h2><pre><code>package com.itlwc;  

import java.util.Arrays;  
import java.util.List;  

public class Test {  
    public static void main(String[] args) {  
        String[] str = { &quot;l&quot;, &quot;w&quot;, &quot;c&quot; };  
        //使用Java类库中java.util.Arrays类的静态方法asList()  
        List l = Arrays.asList(str);  
        System.out.println(str);  
    }  

}  
/* 
打印结果: 
    [l, w, c] 
*/  
</code></pre><h2 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h2><pre><code>ArrayList底层采用数组实现,LinkedList底层采用双链表实现  
如果为列表增加对象  
    ArrayList是ArrayList底层数组维护的,LinkedList是LinkedList底层Entry对象维护的  
    LinkedList底层Entry结构  
        Entry{  
            Entry previous;  
            Object element;  
            Entry next;  
        }  
        其中element就是我们添加的元素,最后将生成的Entry对象加入到链表中  
插入和删除操作时,采用LinkedList好,搜索时,采用ArrayList好  
</code></pre><h2 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a>List<map>遍历</map></h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.Iterator;  
import java.util.List;  
import java.util.Map;  

public class Test {  
    public static void main(String[] args) {  
        Map&lt;Integer, String&gt; map1 = new HashMap&lt;Integer, String&gt;();  
        map1.put(new Integer(1), &quot;lwc&quot;);  
        map1.put(new Integer(2), &quot;nxj&quot;);  
        Map&lt;Integer, String&gt; map2 = new HashMap&lt;Integer, String&gt;();  
        map2.put(new Integer(3), &quot;tom&quot;);  
        map2.put(new Integer(4), &quot;cat&quot;);  
        List&lt;Map&lt;Integer, String&gt;&gt; list = new ArrayList&lt;Map&lt;Integer, String&gt;&gt;();  
        list.add(map1);  
        list.add(map2);  
        // 方法一  
        Iterator&lt;Map&lt;Integer, String&gt;&gt; ite1 = list.iterator();  
        while (ite1.hasNext()) {  
            Map&lt;Integer, String&gt; m = ite1.next();  
            System.out.println(m);  
        }  
        System.out.println(&quot;-----------------------------&quot;);  
        // 方法二(方法一的变形)  
        for (Iterator&lt;Map&lt;Integer, String&gt;&gt; ite2 = list.iterator(); ite2.hasNext();) {  
            Map&lt;Integer, String&gt; m = ite2.next();  
            System.out.println(m);  
        }  
        System.out.println(&quot;-----------------------------&quot;);  
        // 方法三:  
        for (Map&lt;Integer, String&gt; m : list) {  
            System.out.println(m);  
        }  
    }  
}  
/*  
打印结果:  
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
    ----------------------------- 
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
    ----------------------------- 
    {1=lwc, 2=nxj} 
    {3=tom, 4=cat} 
*/  
</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>实现类  
    HashSet,LinkedHashSet  
子接口  
    SortSet  
    实现类  
        TreeSet  
不包含重复元素,最多包含一个null,元素没有顺序  
</code></pre><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><pre><code>HashSet不是Ordered也不是Sorted,存储对象引用时是按照哈希策略来实现的,  
    HashSet中是否存在一个对象是通过equals()和hashCode()协同判断  
不保证顺序  
构造方法  
    public HashSet()    
    public HashSet(int initialCapacity)    
    public HashSet(Collection c)  
HashSet底层是使用HashMap实现的  
HashSet的add()方法详解:  
    判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致  
    如果不一致,直接加进去  
    如果一致,再进行equals()比较  
        如果equals()返回true,对象已经存在不增加进去  
        如果equals()返回false,把对象增加进去  
</code></pre><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><pre><code>LinkedHashSet是Ordered,采用双链表实现的  
有固定顺序,也就是插入顺序  
LinkedHashSet底层是使用LinkedHashMap实现的  
构造方法  
    public LinkedHashSet()    
    public LinkedHashSet(int initialCapacity)    
    public LinkedHashSet(Collection c)  
</code></pre><h2 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h2><pre><code>保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序  
常用方法  
    Object first()  
         返回此有序集合中当前第一个(最小的)元素  
    Object last()  
        返回此有序集合中最后一个(最大的)元素  
    SortedSet headSet(Object toElement)  
        返回此有序集合的部分视图,其元素严格小于toElement  
    SortedSet tailSet(Object fromElement)  
        返回此有序集合的部分视图,其元素大于或等于fromElement  
    SortedSet subSet(Object fromElement,Object toElement)  
        返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括)  
    Comparator comparator()  
        返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null  
</code></pre><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><pre><code>TreeSet是SortedSet接口的实现,元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历  
TreeSet底层是使用TreeMap实现的  
构造方法  
    public TreeSet()  
    public TreeSet(SortedSet s)    
    public TreeSet(int initialCapacity)  
    public TreeSet(Comparator&lt;? super E&gt;)  
    public TreeSet(Collection c)  
因为TreeSet是带排序的,所以想要为TreeSet增加自定义类型,必须指定排序规则
</code></pre><h2 id="TreeSet排序规则Comparator案例"><a href="#TreeSet排序规则Comparator案例" class="headerlink" title="TreeSet排序规则Comparator案例"></a>TreeSet排序规则Comparator案例</h2><pre><code>package com.itlwc;  

import java.util.Comparator;  
import java.util.Iterator;  
import java.util.TreeSet;  

public class Test {  
    public static void main(String[] args) {  
        TreeSet set = new TreeSet(new PersonComparator());  
        set.add(new Person(&quot;lwc&quot;, 80));  
        set.add(new Person(&quot;nxj&quot;, 70));  
        set.add(new Person(&quot;lp&quot;, 60));  
        set.add(new Person(&quot;fy&quot;, 75));  
        Iterator ite = set.iterator();  
        while (ite.hasNext()) {  
            Person p = (Person)ite.next();  
            System.out.println(p.name);  
        }  
    }  
}  

class Person {  
    String name;  
    int score;  

    public Person(String name, int score) {  
        this.name = name;  
        this.score = score;  
    }  
}  

class PersonComparator implements Comparator {  
    public int compare(Object o1, Object o2) {  
        Person p1 = (Person) o1;  
        Person p2 = (Person) o2;  
        return p1.score - p2.score;  
    }  
}  
</code></pre><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>操作Collection类的工具类,类中方法都是静态的</p>
<h2 id="Collections常用方法"><a href="#Collections常用方法" class="headerlink" title="Collections常用方法"></a>Collections常用方法</h2><pre><code>package com.itlwc;  

import java.util.ArrayList;  
import java.util.Collections;  
import java.util.Comparator;  

public class Test {  
    public static void main(String[] args) {  
        // 将所有元素从一个列表复制到另一个列表  
        Collections.copy(new ArrayList(), new ArrayList());  
        // 如果两个指定collection中没有相同的元素,则返回 true  
        Collections.disjoint(new ArrayList(), new ArrayList());  
        // 使用指定元素替换指定列表中的所有元素  
        Collections.fill(new ArrayList(), new Object());  
        // 返回指定 collection 中等于指定对象的元素数  
        Collections.frequency(new ArrayList(), new Object());  
        // 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1  
        Collections.indexOfSubList(new ArrayList(), new ArrayList());  
        // 根据元素的自然顺序，返回给定 collection 的最大元素  
        Collections.max(new ArrayList());  
        // //根据元素的自然顺序，返回给定 collection 的最大元素  
        Collections.min(new ArrayList());  
        // 使用另一个值替换列表中出现的所有某一指定值  
        Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);  
        // 反转指定列表中元素的顺序  
        Collections.reverse(new ArrayList());  
        // 返回一个比较器,它强行反转  
        Collections.reverseOrder();  
        // 返回一个比较器,它强行反转指定比较器的顺序  
        Collections.reverseOrder(new Comparator() {  
            @Override  
            public int compare(Object o1, Object o2) {  
                return 0;  
            }  
        });  
        // 使用默认随机源随机更改指定列表的序列  
        Collections.shuffle(new ArrayList());  
        // 根据元素的自然顺序对指定列表按升序进行排序  
        Collections.sort(new ArrayList());  
        // 根据元素的自然顺序对指定列表按降序进行排序  
        Collections.sort(new ArrayList(), Collections.reverseOrder());  
        // 在指定列表的指定位置处交换元素  
        Collections.swap(new ArrayList(), 1, 2);  

    }  
}  
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_多态的性质]]></title>
      <url>/2017/06/06/Java-%E5%A4%9A%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      <content type="html"><![CDATA[<p>面向对象编程有三大特性：封装、继承、多态。</p>
<p>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</p>
<p>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：</p>
<pre><code>酒 a = 剑南春

酒 b = 五粮液

酒 c = 酒鬼酒

…
</code></pre><p>这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p>
<p>诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：</p>
<pre><code>JNC a = new  JNC();
</code></pre><p>对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？</p>
<pre><code>Wine a = new JNC();
</code></pre><p>在这里我们这样理解，这里定义了一个Wine类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了。</p>
<pre><code>public class Wine {
    public void fun1(){
        System.out.println(&quot;Wine 的Fun.....&quot;);
        fun2();
    }

    public void fun2(){
        System.out.println(&quot;Wine 的Fun2...&quot;);
    }
}

public class JNC extends Wine{
    /**
     * @desc 子类重载父类方法
     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的
     * @param a
     * @return void
     */
    public void fun1(String a){
        System.out.println(&quot;JNC 的 Fun1...&quot;);
        fun2();
    }

    /**
     * 子类重写父类方法
     * 指向子类的父类引用调用fun2时，必定是调用该方法
     */
    public void fun2(){
        System.out.println(&quot;JNC 的Fun2...&quot;);
    }
}

public class Test {
    public static void main(String[] args) {
        Wine a = new JNC();
        a.fun1();
    }
}
-------------------------------------------------
Output:
Wine 的Fun.....
JNC 的Fun2...
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java_final 和 static]]></title>
      <url>/2017/06/06/Java-final-%E5%92%8C-static/</url>
      <content type="html"><![CDATA[<p>Java关键字final、static使用总结</p>
<h2 id="一、final"><a href="#一、final" class="headerlink" title="一、final"></a>一、final</h2><p>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br>final类不能被继承，没有子类，final类中的方法默认是final的。<br>final方法不能被子类的方法覆盖，但可以被继承。<br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br>final不能用于修饰构造方法。<br>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<ul>
<li><p>1、final类</p>
<p> final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>
</li>
<li><p>2、final方法</p>
</li>
</ul>
<p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br>使用final方法的原因有二：<br>第一、把方法锁定，防止任何继承类修改它的意义和实现。<br>第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>例如：</p>
<pre><code>public class Test1 {
    public static void main(String[] args) {
    // TODO 自动生成方法存根
    }
    public void f1() {
        System.out.println(&quot;f1&quot;);
    }
    //无法被子类覆盖的方法
    public final void f2() {
        System.out.println(&quot;f2&quot;);
    }
    public void f3() {
        System.out.println(&quot;f3&quot;);
    }
    private void f4() {
        System.out.println(&quot;f4&quot;);
    }
    }
    public class Test2 extends Test1 {

    public void f1(){    
        System.out.println(&quot;Test1父类方法f1被覆盖!&quot;);
    }
    public static void main(String[] args) {
        Test2 t=new Test2();
        t.f1();    
        t.f2(); //调用从父类继承过来的final方法
        t.f3(); //调用从父类继承过来的方法
        //t.f4(); //调用失败，无法从父类继承获得
    }
}
</code></pre><ul>
<li>3、final变量（常量）<br>用final修饰的成员变量表示常量，值一旦给定就无法改变！<br>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。<br>另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</li>
</ul>
<pre><code>package org.leizhimin;

public class Test3 {
        private final String S = &quot;final实例变量S&quot;;
        private final int A = 100;
        public final int B = 90;



 public static final int C = 80;
    private static final int D = 70;
        public final int E; //final空白,必须在初始化对象的时候赋初值



  public Test3(int x) {
            E = x;
    }

/**
 * @param args
 */
public static void main(String[] args) {
        Test3 t = new Test3(2);
        //t.A=101;    //出错,final变量的值一旦给定就无法改变
        //t.B=91; //出错,final变量的值一旦给定就无法改变
        //t.C=81; //出错,final变量的值一旦给定就无法改变
        //t.D=71; //出错,final变量的值一旦给定就无法改变

                System.out.println(t.A);
                System.out.println(t.B);
                System.out.println(t.C); //不推荐用对象方式访问静态字段
                System.out.println(t.D); //不推荐用对象方式访问静态字段
                System.out.println(Test3.C);
                System.out.println(Test3.D);
                //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同.
                System.out.println(t.E);

            Test3 t1 = new Test3(3);
            System.out.println(t1.E); //final空白变量E依据对象的不同而不同
    }

        private void test() {
                System.out.println(new Test3(1).A);
                System.out.println(Test3.C);
                System.out.println(Test3.D);
        }

        public void test2() {
                final int a;     //final空白,在需要的时候才赋值
                final int b = 4;    //局部常量--final用于局部变量的情形
                final int c;    //final空白,一直没有给赋值.    
                a = 3;
                //a=4;    出错,已经给赋过值了.
                //b=2; 出错,已经给赋过值了.
        }
}
</code></pre><p>4、final参数<br>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p>
<pre><code>public class Test4 {
           public static void main(String[] args) {
                   new Test4().f1(2);
           }
           public void f1(final int i) {
                   //i++;    //i是final类型的,值不允许改变的.
                   System.out.print(i);
           }
   }
</code></pre><p>二、static</p>
<pre><code>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。

被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。

用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。

static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。

static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：
</code></pre><p>类名.静态方法名(参数列表…)<br>类名.静态变量名<br>        用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。</p>
<p>1、static变量<br>        按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br>        对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br>        对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>
<p>2、静态方法<br>        静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br>        因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>3、static代码块<br>        static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<p>public class Test5 {<br>        private static int a;<br>        private int b;</p>
<pre><code>static {
        Test5.a = 3;
        System.out.println(a);
        Test5 t = new Test5();
        t.f();
        t.b = 1000;
        System.out.println(t.b);
}

static {
        Test5.a = 4;
        System.out.println(a);
}

public static void main(String[] args) {
        // TODO 自动生成方法存根
}

static {
        Test5.a = 5;
        System.out.println(a);
}

public void f() {
        System.out.println(&quot;hhahhahah&quot;);
}
</code></pre><p>}</p>
<p>运行结果：<br>3<br>hhahhahah<br>1000<br>4<br>5<br>        利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>
<p>4、static和final一块用表示什么<br>        static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>        对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>        对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<pre><code>特别要注意一个问题：
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。
也许说了这么多，反倒把你搞晕了，还是看个例子吧：
</code></pre><p>public class TestStaticFinal {<br>        private static final String strStaticFinalVar = “aaa”;<br>        private static String strStaticVar = null;<br>        private final String strFinalVar = null;<br>        private static final int intStaticFinalVar = 0;<br>        private static final Integer integerStaticFinalVar = new Integer(8);<br>        private static final ArrayList<string> alStaticFinalVar = new ArrayList<string>();</string></string></p>
<pre><code>private void test() {
        System.out.println(&quot;-------------值处理前----------\r\n&quot;);
        System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;);
        System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;);


        //strStaticFinalVar=&quot;哈哈哈哈&quot;;        //错误，final表示终态,不可以改变变量本身.
        strStaticVar = &quot;哈哈哈哈&quot;;                //正确，static表示类变量,值可以改变.
        //strFinalVar=&quot;呵呵呵呵&quot;;                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。
        alStaticFinalVar.add(&quot;aaa&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。
        alStaticFinalVar.add(&quot;bbb&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。

        System.out.println(&quot;-------------值处理后----------\r\n&quot;);
        System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;);
        System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;);
        System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;);
}

public static void main(String args[]) {
        new TestStaticFinal().test();
}
</code></pre><p>}</p>
<p>运行结果如下：<br>————-值处理前———-<br>strStaticFinalVar=aaa<br>strStaticVar=null<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[]<br>————-值处理后———-<br>strStaticFinalVar=aaa<br>strStaticVar=哈哈哈哈<br>strFinalVar=null<br>intStaticFinalVar=0<br>integerStaticFinalVar=8<br>alStaticFinalVar=[aaa, bbb]</p>
<p>Process finished with exit code 0</p>
<pre><code>看了上面这个例子，就清楚很多了，但必须明白：通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方。
</code></pre>]]></content>
      
        <categories>
            
            <category> Java学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建造者模式（Builder Pattern）]]></title>
      <url>/2017/06/06/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>建造者模式（Builder Pattern） 也叫生成器模式其定义如下：<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>四个要素：</p>
<pre><code>产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。

抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。

建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。

导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。
</code></pre><p>#一 Builder模式介绍及使用场景<br>Builder模式是一步一步创建一个复杂对象的创建者模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p>
<p>因为一个复杂的对象有很多大量组成部分，如汽车，有车轮、方向盘、发动机，还有各种小零件，如何将这件部件装配成一辆汽车，这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，也可以使用Builder模式将部件和组装过程分离，使得构建过程和部件都可以自有拓展，两者之间的耦合也降到最低。</p>
<p>在项目中最常见到的两个使用Builder模式的案例，一个是AlertDialog.Builder的创建，另一个就是著名的图片加载框架ImageLoader的初始配置。</p>
<p>ImageLoader的初始配置如下：</p>
<pre><code>ImageLoaderConfiguration config = new ImageLoaderConfiguration  
    .Builder(context)  
    .memoryCacheExtraOptions(480, 800) // max width, max height，即保存的每个缓存文件的最大长宽  
    .discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) // Can slow ImageLoader, use it carefully (Better don&apos;t use it)/设置缓存的详细信息，最好不要设置这个  
    .threadPoolSize(3)//线程池内加载的数量  
    .threadPriority(Thread.NORM_PRIORITY - 2)  
    .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You can pass your own memory cache implementation/你可以通过自己的内存缓存实现  
    .memoryCacheSize(2 * 1024 * 1024)   //设置内存缓存的大小 
    .discCacheSize(50 * 1024 * 1024)    //设置磁盘缓存的大小
    .discCacheFileNameGenerator(new Md5FileNameGenerator())//将保存的时候的URI名称用MD5 加密   
    .discCacheFileCount(100) //缓存的文件数量  
    .discCache(new UnlimitedDiscCache(cacheDir))//自定义缓存路径      
         .defaultDisplayImageOptions(DisplayImageOptions.createSimple())  
    .imageDownloader(new BaseImageDownloader(context, 5 * 1000, 30 * 1000)) // connectTimeout (5 s), readTimeout (30 s)超时时间  
    .writeDebugLogs() // Remove for release app  
    .build();//开始构建
//然后   
 ImageLoader.getInstance().init(config);//全局初始化此配置  
</code></pre><p>Builder模式的使用场景：<br>（1）多个部件或零件，不同的执行顺序，产生不同的事件结果时；<br>（2）多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。<br>（3）当初始化一个对象特别复杂，参数多，且很多参数都具有默认值。</p>
<p>#二 Builder模式的结构图</p>
<p>结构图如下：<br>角色介绍：<br>（1）Product：产品的抽象类<br>（2）Builder：抽象的Builder类，规范产品的组件，一般由子类实现具体的组建过程。<br>（3）ConcreteBuilder: 具体的Builder类。<br>（4）Director：统一的组装过程。</p>
<p><img src="http://img.blog.csdn.net/20160416154928614" alt="此处输入图片的描述"></p>
<p>#三 Builder模式的简单DEMO：</p>
<p><a href="http://blog.csdn.net/hello_haozi/article/details/38819935" target="_blank" rel="external">Builder模式的简单Demo</a></p>
<p>看过了这个例子，可以发现这个例子和我们一开始看到的类似ImageLoade初始配置那样的链式调用是不一样的，因为忽略了Director的角色。</p>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="external">深入理解一下Director的作用</a></p>
<p>#四 分析源码<br>OkHttp</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对RecyclerView Item做动画]]></title>
      <url>/2017/06/06/%E5%AF%B9RecyclerView-Item%E5%81%9A%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p><strong>参考于：<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650820629&amp;idx=1&amp;sn=dafee7298419df6c9161368db7f7198d&amp;scene=4#wechat_redirect" target="_blank" rel="external">由Ru_Zhan投稿的微信文章</a></strong><br>添加动态位移，静态位移，缩放等动画，保证动画状态的平滑衔接。</p>
<p>RecyclerView，ListView这些具有Item复用性的View，想要对其Item做动画，需要注意以下几点： </p>
<ol>
<li>如果要一点击，让所有Item做动画的效果。例如，上图的编辑和取消，这样的动态动画。可以对所有ViewHolder中的View直接做动画。但是需要在onBindViewHolder方法中对复用的item做静态动画，保证动画状态的平滑衔接。</li>
<li>每一个Item的特有属性。例如，上图checkbox的选中状态，都需要把状态字段放到对应的Java bean中，<br>并在onBindViewHolder方法从java bean取出状态值，设置到view里。</li>
</ol>
<h1 id="1-对View的处理"><a href="#1-对View的处理" class="headerlink" title="1.对View的处理"></a>1.对View的处理</h1><p>首先，创建一个View，他是RecyclerView Item的根布局，名字为：SlideRelativeLayout，这里我们重写onFinishInflate，在View树创建完毕之后找到我们需要做动画的子View：</p>
<pre><code>@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mCheckBox = (CheckBox) findViewById(R.id.item_checkbox);
    mContentSlide = (RelativeLayout) findViewById(R.id.item_content_rl);
    setOffset(35);
}
</code></pre><p>然后，设计4个方法，分别为：<br>动态的打开动画</p>
<pre><code>@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public void openAnimation() {
    ValueAnimator valueAnimator = new ValueAnimator();
    valueAnimator.setIntValues(0, 1);
    valueAnimator.setDuration(300);
    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            float fraction = valueAnimator.getAnimatedFraction();
            int endX = (int) (-mOffset * fraction);
            doAnimationSet(endX, fraction);
        }
    });
    valueAnimator.start();
}
</code></pre><p>动态的关闭动画</p>
<pre><code>@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public void closeAnimation() {
    ValueAnimator valueAnimator = new ValueAnimator();
    valueAnimator.setIntValues(0, 1);
    valueAnimator.setDuration(150);
    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            float fraction = valueAnimator.getAnimatedFraction();
            int endX = (int) (-mOffset * (1 - fraction));
            doAnimationSet(endX, (1 - fraction));
        }
    });
    valueAnimator.start();
}
</code></pre><p>静态的打开动画</p>
<pre><code>public void open() {
    mContentSlide.scrollTo(-mOffset, 0);
}
</code></pre><p>静态的关闭动画</p>
<pre><code>public void close() {
        mContentSlide.scrollTo(0, 0);
    }
}
</code></pre><p>对子View做动画我采取的策略是：使用属性动画，在每一帧动画里获取到对应的值，对子View做相应的动画，例如：动态的打开动画，onAnimationUpdate方法，显示每一贞动画都会回调一次。</p>
<p>这样RecylerView Item带有动态动画和静态动画的View就设计好了。</p>
<h1 id="2。对ViewHolder的处理"><a href="#2。对ViewHolder的处理" class="headerlink" title="2。对ViewHolder的处理"></a>2。对ViewHolder的处理</h1><p>在bind方法中使用静态动画，动态动画对外提供方法调用</p>
<pre><code>private class SlideViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {

    private SlideRelativeLayout mSlideRelativeLayout;
    private CheckBox mCheckBox;
    private ItemBean mItemBean;

    public SlideViewHolder(View itemView) {
        super(itemView);
        mSlideRelativeLayout = (SlideRelativeLayout) itemView.findViewById(R.id.item_root);
        mCheckBox = (CheckBox) itemView.findViewById(R.id.item_checkbox);
        itemView.setOnClickListener(this);
    }

    public void bind(ItemBean itemBean) {
        mItemBean = itemBean;
        mCheckBox.setChecked(itemBean.isChecked());
        switch (mState) {
            case NORMAL:
                mSlideRelativeLayout.close();
                break;

            case SLIDE:
                mSlideRelativeLayout.open();
                break;
        }
    }

    public void openItemAnimation() {
        mSlideRelativeLayout.openAnimation();
    }

    public void closeItemAnimation() {
        mSlideRelativeLayout.closeAnimation();
    }

    public void setCheckBox() {
        mCheckBox.setChecked(!mCheckBox.isChecked());
        mItemBean.setChecked(mCheckBox.isChecked());
    }

    @Override
    public void onClick(View view) {
        setCheckBox();
    }
}
</code></pre><p>可以看到静态动画在bind里调用，打开或者关闭是由mState变量决定的。而动态的滑动需要手动调用：</p>
<p>那怎么来使用这些动画呢？ </p>
<p>动态动画的使用方法：存储所有创建出来的ViewHolder，统一调用动态动画方法。并设置mState变量值，防止滑动时动画不能平滑衔接。</p>
<pre><code>public void openItemAnimation() {
    mState = SLIDE;
    for (SlideViewHolder holder : mSlideViewHolders) {
        holder.openItemAnimation();
    }
}

public void closeItemAnimation() {
    mState = NORMAL;
    for (SlideViewHolder holder : mSlideViewHolders) {
        holder.closeItemAnimation();
    }
}
</code></pre><p>而外面又是这样调用的：</p>
<pre><code>private void editItems(){
    if (&quot;编辑&quot;.equals(mRightTV.getText().toString())) {
        mRightTV.setText(&quot;取消&quot;);
        mSlideAdapter.openItemAnimation();
    } else if (&quot;取消&quot;.equals(mRightTV.getText().toString())) {
        mRightTV.setText(&quot;编辑&quot;);
        mSlideAdapter.closeItemAnimation();
    }
}
</code></pre><p>总体就是：点击按钮 – 变量ViewHolder集合做动态动画，并设置mState变量 – 手机滑动屏幕走bind方法又是根据mState做静态动画，动画从而平滑的衔接起来。</p>
<p>动态动画起先，设置状态值，引导处理正确的静态动画，RecyclerView item的动画处理是不是变简单了。</p>
<p>还有，对item的特殊数据需要在对应的java bean里设置值，在bind方法取值设置到item中去。</p>
<h1 id="在这个过程中遇到的问题"><a href="#在这个过程中遇到的问题" class="headerlink" title="在这个过程中遇到的问题"></a>在这个过程中遇到的问题</h1><pre><code>@Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        SlideViewHolder slideViewHolder;
//        View view;
//        view=inflater.inflate(R.layout.item, parent,false);
        slideViewHolder = new SlideViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item,parent,false));
        mSlideViewHolders.add(slideViewHolder);
        return slideViewHolder;
    }
</code></pre><p>中<code>slideViewHolder = new SlideViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item,parent,false));</code><br>每次都会崩这里后来发现是XML里我自定义View的名称写错了，但是在改bug的时候并没有报错所以改了很久，然后就顺便学习了一下[什么是Context][2]我们总是用到，但是否想过Context到底是什么呢？</p>
<h2 id="2-http-www-jianshu-com-p-94e0f9ab3f1d"><a href="#2-http-www-jianshu-com-p-94e0f9ab3f1d" class="headerlink" title="  [2]: http://www.jianshu.com/p/94e0f9ab3f1d"></a>  [2]: <a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">http://www.jianshu.com/p/94e0f9ab3f1d</a></h2>]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 自定义view </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 多线程]]></title>
      <url>/2017/06/06/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>在学习java的时候，你们一定对多线程这个词不陌生，而android多线程跟java相比并没有什么特殊的地方，基本都是相同的语法。<br>而线程的使用就是在执行一些耗时的操作，比如发起一条网络请求时，考虑到网速等原因，服务器不一定会立刻响应我们的请求，如果不把这些操作放在子线程中，会导致主线程被阻塞，从而影响用户对软件的正常使用。</p>
<h1 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h1><p>下面先看一下android中，三种启用线程的方法</p>
<h2 id="1-只需要新建一个类继承自Thread，然后重写父类的run-方法来实现一个线程："><a href="#1-只需要新建一个类继承自Thread，然后重写父类的run-方法来实现一个线程：" class="headerlink" title="1.只需要新建一个类继承自Thread，然后重写父类的run()方法来实现一个线程："></a>1.只需要新建一个类继承自Thread，然后重写父类的<code>run()</code>方法来实现一个线程：</h2><pre><code>public class MyThread extends Thread {  

    //继承Thread类，并改写其run方法        
    private final static String TAG = &quot;My Thread ===&gt; &quot;;      
    public void run(){  
        //具体的实现
        Log.d(TAG, &quot;run&quot;);  
        for(int i = 0; i&lt;100; i++)  
        {  
            Log.e(TAG, Thread.currentThread().getName() + &quot;i =  &quot; + i);  
        }  
    }  
} 
</code></pre><p>启动：</p>
<pre><code>new MyThread().start();
</code></pre><h2 id="2-创建一个实现Runnable接口的对象"><a href="#2-创建一个实现Runnable接口的对象" class="headerlink" title="2.创建一个实现Runnable接口的对象"></a>2.创建一个实现Runnable接口的对象</h2><pre><code>public class MyRunnable implements Runnable{  
    private final static String TAG = &quot;My Runnable ===&gt; &quot;;  

    @Override  
    public void run() {  
         //具体的逻辑
        // TODO Auto-generated method stub  
        Log.d(TAG, &quot;run&quot;);  
        for(int i = 0; i&lt;1000; i++)  
        {  
            Log.e(TAG, Thread.currentThread().getName() + &quot;i =  &quot; + i);  
        }  
    }  
} 
</code></pre><p>启动：</p>
<pre><code>new Thread(new MyRunnable()).start(); 
</code></pre><p>可以看到，<code>Thread</code>的构造函数接受一个<code>Runnable</code>参数，而我们<code>new</code>出的<code>MyRunnable</code>正是一个实现了<code>Runnable</code>接口的对象，所以可以直接将他传入到<code>Thread</code>的构造函数里。接着调用<code>Thread</code>的<code>start()</code>方法，<code>run()</code>方法中的代码就会在子线程中运行了。</p>
<h2 id="3-另外一种启用方式：匿名类（常见）"><a href="#3-另外一种启用方式：匿名类（常见）" class="headerlink" title="3.另外一种启用方式：匿名类（常见）"></a>3.另外一种启用方式：匿名类（常见）</h2><pre><code>btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        try {
                           //具体逻辑
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }).start();
            }
        });
</code></pre><p>#异步消息处理机制</p>
<h2 id="1-尝试在子线程中更新UI"><a href="#1-尝试在子线程中更新UI" class="headerlink" title="1.尝试在子线程中更新UI"></a>1.尝试在子线程中更新UI</h2><pre><code>看代码
</code></pre><p>和其他许多GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常。<br>上面这个例子就恰好证明了android确实不能在子线程中进行UI操作的，但是有些时候，我们必须在子线程中执行一些耗时任务，然后再根据执行结果来更新UI，这时候就要用到异步消息处理机制。</p>
<h2 id="2-Message，Handler，MessageQueue和Looper"><a href="#2-Message，Handler，MessageQueue和Looper" class="headerlink" title="2.Message，Handler，MessageQueue和Looper"></a>2.Message，Handler，MessageQueue和Looper</h2><pre><code>看代码
</code></pre><p><img src="http://img.blog.csdn.net/20140805002935859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Looper，Handler，message三者关系图"></p>
<h2 id="3-进一步探究Handler-Looper机制"><a href="#3-进一步探究Handler-Looper机制" class="headerlink" title="3.进一步探究Handler Looper机制"></a>3.进一步探究Handler Looper机制</h2><p>要分析Handler Looper机制，自然想到去看Handler类和Looper类的源码(分别位于Handler.java和Looper.java两个文件中)。简单阅读两个类的描述后，在Looper类的描述中能找到以下一段示例代码。</p>
<pre><code>&lt;p&gt;This is a typical example of the implementation of a Looper thread,
* using the separation of {@link #prepare} and {@link #loop} to create an
* initial Handler to communicate with the Looper.
*
* &lt;pre&gt;
*  class LooperThread extends Thread {
*      public Handler mHandler;
*
*      public void run() {
*          Looper.prepare();
*
*          mHandler = new Handler() {
*              public void handleMessage(Message msg) {
*                  // process incoming messages here
*              }
*          };
*
*          Looper.loop();
*      }
*  }&lt;/pre&gt;
*/
</code></pre><p>这段代码给出了Handler Looper机制实现进程间通信的三大基本步骤，包括Looper的两个函数prepare()和loop()，以及Handler的handleMessage函数。<br><img src="http://s3.51cto.com/wyfs02/M00/4C/6D/wKioL1Q9Ep3hhE3cAAE6NKlEbfI860.jpg" alt="Handler Looper关系总结"><br> 由图可见，基于Handler Looper机制传递消息主要包括以下几个步骤。</p>
<pre><code>(1)目标线程调用Looper.prepare()创建Looper对象和消息队列。

(2)目标线程通过new Handler()创建handler对象，将Handler,Looper，消息队列三者关联起来。并覆盖其handleMessage函数。

(3)目标线程调用Looper.loop()监听消息队列。

(4)消息源线程调用Handler.sendMessage发送消息。

(5)消息源线程调用MessageQueue.enqueueMessage将待发消息插入消息队列。

(6)目标线程的loop()检测到消息队列有消息插入，将其取出。

(7)目标线程将取出的消息通过Handler.dispatchMessage派发给Handler.handleMessage进行消息处理。
</code></pre><h2 id="4-使用AsyncTask"><a href="#4-使用AsyncTask" class="headerlink" title="4.使用AsyncTask"></a>4.使用AsyncTask</h2><p>android提供了一个很好的工具，就比如AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单的从子线程切换到主线程。<br>首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：</p>
<pre><code>1. Params
在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。
2. Progress
后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。
3. Result
当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。
</code></pre><p>因此，一个最简单的自定义AsyncTask就可以写成如下方式：</p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  
    ……  
}
</code></pre><p>这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。</p>
<p>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：</p>
<pre><code>1. onPreExecute()
这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。
2. doInBackground(Params...)
这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress...)方法来完成。
3. onProgressUpdate(Progress...)
当在后台任务中调用了publishProgress(Progress...)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。
4. onPostExecute(Result)
当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。
</code></pre><p>因此，一个比较完整的自定义AsyncTask就可以写成如下方式：</p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  

    @Override  
    protected void onPreExecute() {  
        progressDialog.show();  
    }  

    @Override  
    protected Boolean doInBackground(Void... params) {  
        try {  
            while (true) {  
                int downloadPercent = doDownload();  
                publishProgress(downloadPercent);  
                if (downloadPercent &gt;= 100) {  
                    break;  
                }  
            }  
        } catch (Exception e) {  
            return false;  
        }  
        return true;  
    }  

    @Override  
    protected void onProgressUpdate(Integer... values) {  
        progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  
    }  

    @Override  
    protected void onPostExecute(Boolean result) {  
        progressDialog.dismiss();  
        if (result) {  
            Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  
        } else {  
            Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  
        }  
    }  
}  
</code></pre><p>这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可：</p>
<pre><code>new DownloadTask().execute(); 
</code></pre><p> 如果想深入学习还是推荐研究一下源码。</p>
<p>#浅谈服务<br>Service是Android中的四大组件之一，和windows中的服务是类似，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序Service，手机中有的程序的更新，服务的推送。Android系统中，Service与Activity类似，都需要AndroidManifest.xml文件中配置，而且生命周期有点类似。Service不像Activity在前台运行，而是默默的在后台默默的工作</p>
<p><a href="http://www.cnblogs.com/xiaofeixiang/p/4077587.html" target="_blank" rel="external">浅谈Android组件之Service</a></p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 传感器开发解析]]></title>
      <url>/2017/06/06/Android-%E4%BC%A0%E6%84%9F%E5%99%A8%E5%BC%80%E5%8F%91%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Android为我们提供了传感器框架（Android sensor framework，简称ASF）可以用来访问当前Android设备内置的传感器。ASF提供了很多类和接口，帮助我们完成各种与传感器有关的任务。例如：</p>
<p>1）确定当前Android设备内置了哪些传感器。<br>2）确定某一个传感器的技术指标。<br>3）获取传感器传回来的数据，以及定义传感器回传数据的精度。<br>4）注册和注销传感器事件监听器，这些监听器用于监听传感器的变化，通常从传感器回传的数据需要利用这些监听器完成。</p>
<p>ASF允许我们访问很多传感器类型，这些传感器有一些是基于硬件的传感器，还有一些是基于软件的传感器。基于硬件的传感器就是直接以芯片形式嵌入到Android设备中，这些传感器直接从外部环境获取数据。基于软件的传感器并不是实际的硬件芯片，基于软件的传感器传回的数据本质上也来自于基于硬件的传感器，只是这些数据通常会经过二次加工。所以基于软件的传感器也可以称为虚拟（virtual）传感器或合成（synthetic）传感器。</p>
<p>Android对每个设备的传感器都进行了抽象，其中SensorManger类用来控制传感器，Sensor用来描述具体的传感器，SensorEventListener用来监听传感器值的改变。</p>
<p>（1）SensorManager类</p>
<p>用于创建sensor service的实例。该类提供了很多用于访问和枚举传感器，注册和注销传感器监听器的方法。而且还提供了与传感器精度、扫描频率、校正有关的常量。</p>
<p>（2）Sensor类</p>
<p>Sensor类为我们提供了一些用于获取传感器技术参数的方法。如版本、类型、生产商等。例如所有传感器的TYPE类型如下：<br>序号  传感器 Sensor类中定义的TYPE常量<br>1   加速度传感器  TYPE_ACCELEROMETER<br>2   温度传感器   TYPE_AMBIENT_TEMPERATURE<br>3   陀螺仪传感器  TYPE_GYROSCOPE<br>4   光线传感器   TYPE_LIGHT<br>5   磁场传感器   TYPE_MAGNETIC_FIELD<br>6   压力传感器   TYPE_PRESSURE<br>7   临近传感器   TYPE_PROXIMITY<br>8   湿度传感器   TYPE_RELATIVE_HUMIDITY<br>9   方向传感器   TYPE_ORIENTATION<br>10  重力传感器   TYPE_GRAVITY<br>11  线性加速传感器 TYPE_LINEAR_ACCELERATION<br>12  旋转向量传感器 TYPE_ROTATION_VECTOR<br>注意：1-8是硬件传感器，9是软件传感器，其中方向传感器的数据来自重力和磁场传感器，10-12是硬件或软件传感器。</p>
<p>（3）SensorEvent类</p>
<p>系统使用该类创建传感器事件对象。该对象可以提供与传感器事件有关的信息。传感器事件对象包括的信息有原始的传感器回传数据、传感器类型、数据的精度以及触发事件的时间。</p>
<p>（4）SensorEventListener接口</p>
<p>该接口包含两个回调方法，当传感器的回传值或精度发生变化时，系统会调用这两个回调方法。</p>
<pre><code>/**
* 传感器精度变化时回调
*/
@Override
public void onAccuracyChanged(Sensor sensor, int accuracy) {
}
/**
* 传感器数据变化时回调
*/
@Override
public void onSensorChanged(SensorEvent event) {
}
</code></pre><p>到了这里，我们就可以进行传感器开发工作了。</p>
]]></content>
      
        <categories>
            
            <category> Android学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 传感器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World——写在迁移了我的Blog之后]]></title>
      <url>/2017/06/06/hello-world/</url>
      <content type="html"><![CDATA[<p>我在2016年4月份的时候用<code>githubpages+hexo</code>搭建了自己的博客，期间积累了几篇自己的学习笔记。</p>
<p>然而良久没有更新，自己写的也不勤，然后就在2017年6月1日，我使用的<code>多说评论</code>第三方评论工具被关停了==加上我刚刚换了固态硬盘，博客配置文件丢失，所以我就趁这个机会重新换了个主题<code>next</code>，重头整理搭建我的博客。</p>
<p>六月是一个新的开始，明天就是高考过去两年，这两年的时间里我变了很多，比起当时可能我依旧很迷茫。<br>比如我现在纠结的是放弃别的事情，一心准备考研还是好好搞技术毕业去找工作。昨晚上友仔大君的话确实是对的，我不适合考研，我不适合静心去读书刷题。然而我现在的技术还很烂，去找工作自己有没有多少本事。<br>今年上半年发生了很多事情，在和组里的伙伴们做完<code>家庭助手</code>这个比赛项目之后我自己在心里给自己放了一个假。一泄气就到了今天。我想我心里有很多压力一直得不到释放，总总原因积累了很长时间。直到现在我才醒悟，旁人都开着车从我身边急驰而去，我要抓紧跟上。</p>
<p>我给自己半年时间吧，可能等半年后我才能找到自己的路。这半年弥足珍贵。</p>
<p>提醒自己，心太浮躁了。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 新的开始 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
